<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Effective-Modern-Cpp(3) Moving to Modern C++ | Enclave-X</title><meta name="keywords" content="note"><meta name="author" content="DeeEll-X"><meta name="copyright" content="DeeEll-X"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="Item 7: Distinguish between () and {} creating objects Braced initialization is the most widely usable initializations syntax  Specify default initialization values foor non-static data members 123456">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective-Modern-Cpp(3) Moving to Modern C++">
<meta property="og:url" content="http://deeell-x.github.io/2020/10/22/Effective-Modern-Cpp3/index.html">
<meta property="og:site_name" content="Enclave-X">
<meta property="og:description" content="Item 7: Distinguish between () and {} creating objects Braced initialization is the most widely usable initializations syntax  Specify default initialization values foor non-static data members 123456">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://deeell-x.github.io/null">
<meta property="article:published_time" content="2020-10-22T07:39:00.000Z">
<meta property="article:modified_time" content="2020-10-26T09:23:59.603Z">
<meta property="article:author" content="DeeEll-X">
<meta property="article:tag" content="note">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://deeell-x.github.io/null"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://deeell-x.github.io/2020/10/22/Effective-Modern-Cpp3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-10-26 17:23:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">6</div></a></div></div></div><hr/></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-7-Distinguish-between-and-creating-objects"><span class="toc-number">1.</span> <span class="toc-text">Item 7: Distinguish between () and {} creating objects</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-8-Prefer-nullptr-to-0-and-NULL"><span class="toc-number">2.</span> <span class="toc-text">Item 8: Prefer nullptr to 0 and NULL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-9-Prefer-alias-declarations-to-typedef-s"><span class="toc-number">3.</span> <span class="toc-text">Item 9: Prefer alias declarations to typedef s</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-10-Prefer-scoped-enums-to-unscoped-enums"><span class="toc-number">4.</span> <span class="toc-text">Item 10: Prefer scoped enums to unscoped enums</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-11-Prefer-deleted-functions-to-private-undefined-ones"><span class="toc-number">5.</span> <span class="toc-text">Item 11: Prefer deleted functions to private undefined ones</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-12-Declare-overriding-functions-override"><span class="toc-number">6.</span> <span class="toc-text">Item 12: Declare overriding functions override</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-13-Prefer-const-iterators-to-iterators"><span class="toc-number">7.</span> <span class="toc-text">Item 13: Prefer const_iterators to iterators</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-14-Declare-functions-noexcept-if-they-won%E2%80%99t-emit-exceptions"><span class="toc-number">8.</span> <span class="toc-text">Item 14: Declare functions noexcept if they won’t emit exceptions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-15-Use-constexpr-whenever-possible"><span class="toc-number">9.</span> <span class="toc-text">Item 15: Use constexpr whenever possible</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-16-Make-const-member-functions-thread-safe"><span class="toc-number">10.</span> <span class="toc-text">Item 16: Make const member functions thread safe</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Item-17-Understand-special-member-function-generation"><span class="toc-number">11.</span> <span class="toc-text">Item 17: Understand special member function generation</span></a></li></ol></div></div></div><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Enclave-X</a></span><span id="menus"><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Effective-Modern-Cpp(3) Moving to Modern C++</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-10-22T07:39:00.000Z" title="Created 2020-10-22 15:39:00">2020-10-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2020-10-26T09:23:59.603Z" title="Updated 2020-10-26 17:23:59">2020-10-26</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="Item-7-Distinguish-between-and-creating-objects"><a href="#Item-7-Distinguish-between-and-creating-objects" class="headerlink" title="Item 7: Distinguish between () and {} creating objects"></a>Item 7: Distinguish between () and {} creating objects</h2><ul>
<li><p>Braced initialization is the most widely usable initializations syntax</p>
<ul>
<li><p>Specify default initialization values foor non-static data members</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Widget&#123;</span><br><span class="line">...</span><br><span class="line">private:</span><br><span class="line">	int x&#123;0&#125;;   &#x2F;&#x2F; fine</span><br><span class="line">	int y &#x3D; 0;  &#x2F;&#x2F; fine</span><br><span class="line">	int z(0);   &#x2F;&#x2F; error!	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Braced initialization prohibits narrowing conversions among built-in types, while initialization using parentheses and “=” doesn’t check for narrowing conversions</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double x, y, z;</span><br><span class="line">...</span><br><span class="line">int sum1&#123; x + y + z &#125;; 	&#x2F;&#x2F;error!</span><br><span class="line">int sum2( x + y + z );	&#x2F;&#x2F;okay(value of expression truncated to an int)</span><br><span class="line">int sum3 &#x3D; x + y + z; 	&#x2F;&#x2F;ditto</span><br></pre></td></tr></table></figure>
</li>
<li><p>Prevent the most vexing parse</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Widget w2();		&#x2F;&#x2F;most vexing parse! declares a function named w2 that return a Widget</span><br><span class="line">Widget w3&#123;&#125;;		&#x2F;&#x2F;calls Widget ctor with no args</span><br></pre></td></tr></table></figure>
</li>
<li><p>During constructor overload resolution, braced initializers are matched to std::initializer_list parameters if at all possible, even if other construc‐ tors offer seemingly better matches.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">public:</span><br><span class="line">  Widget(int i, bool b);    &#x2F;&#x2F; as before</span><br><span class="line">  Widget(int i, double d);  &#x2F;&#x2F; as before</span><br><span class="line">  Widget(std::initializer_list&lt;bool&gt; il);   &#x2F;&#x2F; element type is</span><br><span class="line">                                            &#x2F;&#x2F; now bool</span><br><span class="line">  ...</span><br><span class="line">&#125;;    &#x2F;&#x2F; no implicit</span><br><span class="line">      &#x2F;&#x2F; conversion funcs</span><br><span class="line">Widget w&#123;10,5.0&#125;;           &#x2F;&#x2F; error! requires narrowing conversions</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="Item-8-Prefer-nullptr-to-0-and-NULL"><a href="#Item-8-Prefer-nullptr-to-0-and-NULL" class="headerlink" title="Item 8: Prefer nullptr to 0 and NULL"></a>Item 8: Prefer nullptr to 0 and NULL</h2><ul>
<li>0 and NULL are integral, neither 0 nor NULL has a pointer type, they are  interpreted into pointer only when necessary.<br>The type <code>std::nullptr_t</code>  implicitly converts to all raw pointer types, and that’s what makes nullptr act as if it were a pointer of all types.</li>
<li>Prefer nullptr to 0 and NULL.</li>
<li>Avoid overloading on integral and pointer types.</li>
</ul>
<h2 id="Item-9-Prefer-alias-declarations-to-typedef-s"><a href="#Item-9-Prefer-alias-declarations-to-typedef-s" class="headerlink" title="Item 9: Prefer alias declarations to typedef s"></a>Item 9: Prefer alias declarations to typedef s</h2><ul>
<li><p><strong>typedef</strong> s don’t support templatization, but alias declarations do.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">using MyAllocList &#x3D; std::list&lt;T, MyAlloc&lt;T&gt;&gt;; </span><br><span class="line"></span><br><span class="line">MyAllocList&lt;Widget&gt; lw; &#x2F;&#x2F; alias declaration</span><br></pre></td></tr></table></figure>

<p>But typedef needs to be created from scratch：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct MyAllocList &#123;</span><br><span class="line"> 	typedef std::list&lt;T, MyAlloc&lt;T&gt;&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyAllocList&lt;Widget&gt;::type lw;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Alias templates avoid the “<em>::type</em>“ suffix and, in templates the “<em>typename</em>“ prefix often required to refer the <em>typedef</em>s.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class A &#123;</span><br><span class="line">private:</span><br><span class="line"> 	typename MyAllocList&lt;T&gt;::type list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>When compilers process the Widget template and encounter the use of <code>MyAllocList&lt;T&gt;</code> (i.e., use of the alias template), they know that <code>MyAllocList&lt;T&gt;</code> is the name of a type, because MyAllocList is an alias template: it <em>must</em> name a type. <code>MyAllocList&lt;T&gt;</code> is thus a <em>non-dependent type</em>, and a typename specifier is neither required nor permitted.</p>
<p>When compilers see <code>MyAllocList&lt;T&gt;::type</code> (i.e., use of the nested <em>typedef</em>) in the Widget template, on the other hand, they can’t know for sure that it names a type, because there might be a specialization of MyAllocList that they haven’t yet seen where <code>MyAllocList&lt;T&gt;::type</code> refers to something other than a type. </p>
<p>So <code>typename</code> is necessary.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt;</span><br><span class="line">class MyAllocList&lt;Wine&gt; &#123;</span><br><span class="line">private:</span><br><span class="line">  enum class WineType &#123; White, Red, Rose &#125;;</span><br><span class="line">  WineType type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++ 14 offers alias templates for all the C++11 type traits transformation. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::remove_const&lt;T&gt;::type      &#x2F;&#x2F; C++11: const T → T</span><br><span class="line">std::remove_const_t&lt;T&gt;          &#x2F;&#x2F; C++14 equivalent</span><br><span class="line">std::remove_reference&lt;T&gt;::type  &#x2F;&#x2F; C++11: T&amp;&#x2F;T&amp;&amp; → T</span><br><span class="line">std::remove_reference_t&lt;T&gt;      &#x2F;&#x2F; C++14 equivalent</span><br><span class="line">std::add_lvalue_reference&lt;T&gt;::type  &#x2F;&#x2F; C++11: T → T&amp;</span><br><span class="line">std::add_lvalue_reference_t&lt;T&gt;      &#x2F;&#x2F; C++14 equivalent</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Item-10-Prefer-scoped-enums-to-unscoped-enums"><a href="#Item-10-Prefer-scoped-enums-to-unscoped-enums" class="headerlink" title="Item 10: Prefer scoped enums to unscoped enums"></a>Item 10: Prefer scoped enums to unscoped enums</h2><ul>
<li><p>C++98-style <em>enums</em> are now known as unscoped <em>enums</em>, C++11-scoped. Scoped enums have several compelling advantages:</p>
<ul>
<li>Enumerators of scoped <em>enums</em> are visible only within the enum. Scoped enums don’t leak names in unscoped way.</li>
<li>Scoped <em>enums</em> enumerators are much more strongly typed. There are no implicit conversions from enumerator in a scoped <em>enum</em> to any other type.(use <code>static_cast&lt;T&gt;()</code>)</li>
<li>Scoped enums may be forward-declared without specifying their enumerators. Both scoped and unscoped enums support specification of the underlying type. The default underlying type for scoped enums is int. Unscoped snums have no default underlying type.</li>
<li>Scoped enums may always be forward-declared. Unscoped enums may be forward-declared only if their declaration specifies an underlying type.</li>
</ul>
</li>
<li><p>At least one situation where unscoped enums may be useful. Like refering to fields within C++11’s <code>std::tuple</code>, the implicit cast helps.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UserInfo =                <span class="comment">// type alias; see Item 9</span></span><br><span class="line">      <span class="built_in">std</span>::tuple&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,   <span class="comment">// name</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span>,              <span class="comment">// email</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="keyword">size_t</span>&gt; ;            <span class="comment">// reputation</span></span><br><span class="line"><span class="keyword">enum</span> UserInfoFields &#123; uiName, uiEmail, uiReputation &#125;;</span><br><span class="line">UserInfo info;                  <span class="comment">// object of tuple type</span></span><br><span class="line">...</span><br><span class="line"> <span class="keyword">auto</span> val = <span class="built_in">std</span>::get&lt;uiEmail&gt;   <span class="comment">// get value of field email</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Item-11-Prefer-deleted-functions-to-private-undefined-ones"><a href="#Item-11-Prefer-deleted-functions-to-private-undefined-ones" class="headerlink" title="Item 11: Prefer deleted functions to private undefined ones"></a>Item 11: Prefer deleted functions to private undefined ones</h2><ul>
<li><p>Prefer deleted functions to private undefined ones</p>
<ul>
<li><p>Deleted functions may not be used in any way, so even code that’s in member and friend functions will fail to compile if it tries to call deleted functions.</p>
</li>
<li><p>Deleted functions are declared <em>public</em>, not <em>private</em>. When cilent code tries to use a deleted private function, some compilers complain only about the function being private, even though the function’s accessibility doesn’t really affect whether it can be used. Making deleted functions public will generally result in better error messages.</p>
</li>
<li><p>Overload functions can be deleted.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">int</span> number)</span></span>;       <span class="comment">// original function</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">char</span>)</span> </span>= <span class="keyword">delete</span>;    <span class="comment">// reject chars</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">bool</span>)</span> </span>= <span class="keyword">delete</span>;    <span class="comment">// reject bools</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">double</span>)</span> </span>= <span class="keyword">delete</span>;  <span class="comment">// reject doubles and floats</span></span><br><span class="line"><span class="comment">// c++ prefers the float-to-double conversion to a float-to-int one.</span></span><br><span class="line"><span class="comment">// calling isLucky with a float will call the double overload, not the int one.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Template functions can be deleted. The template specializations must be written at namespace scope, not class scope. But this issue doesn’t arise for deleted functions. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span></span></span><br><span class="line"><span class="function">  </span>&#123;... &#125;</span><br><span class="line">  ...</span><br><span class="line"><span class="comment">// private:</span></span><br><span class="line"><span class="comment">//  template&lt;&gt;                    //error!</span></span><br><span class="line"><span class="comment">//  void processPointer&lt;void&gt;(void*);</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> Widget::processPointer&lt;<span class="keyword">void</span>&gt;(<span class="keyword">void</span>*) = <span class="keyword">delete</span>;  <span class="comment">// still public, but deleted</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="Item-12-Declare-overriding-functions-override"><a href="#Item-12-Declare-overriding-functions-override" class="headerlink" title="Item 12: Declare overriding functions override"></a>Item 12: Declare overriding functions override</h2><ul>
<li><p>Declare overriding functions <em>override</em>.</p>
<ul>
<li>For overriding to occur, several requirements must be met.<ul>
<li>The base class function must be virtual.</li>
<li>The base and derived function names must be identical (except in the case of destructors).</li>
<li>The parameter types of the base and derived functions must be identical. The constness of the base and derived functions must be identical.</li>
<li>The return types and exception specifications of the base and derived functions must be compatible.</li>
</ul>
</li>
<li>C++11 gives you a way to make explicit that a derived class function is supposed to override a base class version: declare it <em>override</em>.</li>
</ul>
</li>
<li><p>Member function reference qualifiers make it possible to treat lvalue and rvalue objects(*this) differently.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">public:</span><br><span class="line">  using DataType &#x3D; std::vector&lt;double&gt;;</span><br><span class="line">  ...</span><br><span class="line">  DataType&amp; data() &amp;  &#x2F;&#x2F; for lvalue Widgets,(have address)</span><br><span class="line">  &#123; return values; &#125;  &#x2F;&#x2F; return lvalue</span><br><span class="line">  DataType data() &amp;&amp;  &#x2F;&#x2F; for rvalue Widgets,</span><br><span class="line">  &#123; return std::move(values); &#125; &#x2F;&#x2F; return rvalue</span><br><span class="line">...</span><br><span class="line">private:</span><br><span class="line">  DataType values;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Item-13-Prefer-const-iterators-to-iterators"><a href="#Item-13-Prefer-const-iterators-to-iterators" class="headerlink" title="Item 13: Prefer const_iterators to iterators"></a>Item 13: Prefer <em>const_iterators</em> to <em>iterators</em></h2><ul>
<li>Prefer const_iterators to iterators</li>
<li>In maximally generic code, prefer non-member versions of begin, end, begin,etc. over their member function counterparts.<ul>
<li><code>std::cbegin(container)</code></li>
</ul>
</li>
</ul>
<h2 id="Item-14-Declare-functions-noexcept-if-they-won’t-emit-exceptions"><a href="#Item-14-Declare-functions-noexcept-if-they-won’t-emit-exceptions" class="headerlink" title="Item 14: Declare functions noexcept if they won’t emit exceptions"></a>Item 14: Declare functions <em>noexcept</em> if they won’t emit exceptions</h2><ul>
<li><pre><code>int f(int x) throw();     // no exceptions from f: C++98 style
int f(int x) *noexcept*;  // no exceptions from f: c++11 style</code></pre>
<p><em>noexcept</em> is part of a function’s interface, and that means that callers may depend on it.</p>
</li>
<li><p><em>noexcept</em> functions are more optimizable than non-<em>noexcept</em> functions.</p>
<ul>
<li>If  <code>move()</code>  is <em>noexcept</em> ，<code>push_back</code>  when vector need to maximize its capacity, it can use <code>move()</code>  instead of <code>copy()</code> </li>
</ul>
</li>
<li><p><em>noexcept</em> is particularly valuable for the move operations, swap, memory deallocation functions and destructors. </p>
<ul>
<li>destructors are that way by default unless explicitly declares “<code>noexcept(false)</code>“</li>
</ul>
</li>
<li><p>Optimization is important, but correctness is more important. User should declare a function <em>noexcept</em> only if users are willling to commit to a <em>noexcept</em> implementation over the long term.<br>Sometimes being <em>noexcept</em> can have such a significant payoff, it’s worth implementing them in a <em>noexcept</em> manner if at all possible.</p>
</li>
<li><p>Most functions are exception-neutral rether than <em>noexcept</em>.</p>
</li>
</ul>
<h2 id="Item-15-Use-constexpr-whenever-possible"><a href="#Item-15-Use-constexpr-whenever-possible" class="headerlink" title="Item 15: Use constexpr whenever possible"></a>Item 15: Use <em>constexpr</em> whenever possible</h2><ul>
<li><em>constexpr</em> can be used for variables or functions:<ul>
<li><em>constexpr</em> variables guarantee that a variable has a value that can be used in contexts requiring compile-time constants.</li>
<li><em>constexpr</em> functions can be used in contexts that demand compile-time constants. If the values of the arguments you pass to a <em>constexpr</em> function in such a context are known during compilation, the result will be computed during compilation.<br>When a <em>constexpr</em> function is called with one or more values that are not known during compilation, it acts like a normal function, computing its result at runtime.</li>
</ul>
</li>
<li>In C++11, <em>constexpr</em> funcitons may contain no more than a single executable statement: a return. In C++14, the restrictions on <em>constexpr</em> functions are substantially looser.</li>
<li>In C++11, all built-in types except void, and user-defined types qualify. Because constructors and other member functions may be <em>constexpr</em>.</li>
<li>Use <em>constexpr</em> whenever possible, since both <em>constexpr</em> objects and <em>constexpr</em> functions can be employed in a wider range of contexts than non-<em>constexpr</em> objects and functions. By using con stexpr whenever possible, you maximize the range of situations in which your objects and functions may be used.</li>
<li>Same as <em>noexcept</em>: no regret.</li>
</ul>
<h2 id="Item-16-Make-const-member-functions-thread-safe"><a href="#Item-16-Make-const-member-functions-thread-safe" class="headerlink" title="Item 16: Make const member functions thread safe"></a>Item 16: Make <em>const</em> member functions thread safe</h2><ul>
<li>Make <em>const</em> member functions thread safe unless you’re certain they’ll never be used in a concurrent context.<ul>
<li>mutable specifier:permits modification of the class member declared mutable even if the containing object is declared <em>const</em>.</li>
</ul>
</li>
<li>For a single variable or memory location requiring synchronization, use of a std::atomic is adequate, but once you get to two or more variables or memory locations that require manipulation as a unit, you should reach for a mutex.</li>
<li>Both <code>std::mutex</code> and <code>std::atomic</code> are move-only types. A side effect of adding mutex or atomic to a class is that the class loses the ability to be copied. (It should be moved.)</li>
</ul>
<h2 id="Item-17-Understand-special-member-function-generation"><a href="#Item-17-Understand-special-member-function-generation" class="headerlink" title="Item 17: Understand special member function generation"></a>Item 17: Understand special member function generation</h2><ul>
<li>The special member functions are those compilers may generate on their own: default constructor, destructor, copy constructor, copy assignment, move constructor operator, move assignment operator.</li>
<li>Generated special member functions are <u>implicitly public and inline</u>, and they’re <u>nonvirtual</u> unless the function in question is a destructor in a derived class inheriting from a base class with a virtual destructor.</li>
<li>These functions are generated only if they’re needed.<ul>
<li>Default constructor: Generated only if the class contains no user-declared constructors.</li>
<li>Destructor: Destructors are noexcept by default. Virtual only if a base class destructor is virtual.</li>
<li>Copy constructor: Generated only if the class lacks a user-declared copy constructor. Deleted if the class declares a move operation. Generated of this function  in a class with a user-declared copy assignment operator or destructor is deprecated.</li>
<li>Copy assignment operator: Generated only if the class lacks a user-declared coopy assignment operator. Deleted if the class declares a move operation. Generation of this function in a class with a user declared copy constructor or destructor is deprecated.</li>
<li>Move constructor and move assignment operator: Each performs memberwise moving of non-static data members. <u>Generated only if the class contains no user- declared copy operations, move operations, or destructor.</u></li>
</ul>
</li>
<li>Users can explicity declare a compiler-generated special member function.<ul>
<li>using <code>= default</code></li>
</ul>
</li>
<li>Member function templates never suppress generation of special member functions.(those 6 rules don’t apply to template functions)</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">DeeEll-X</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://deeell-x.github.io/2020/10/22/Effective-Modern-Cpp3/">http://deeell-x.github.io/2020/10/22/Effective-Modern-Cpp3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/note/">note</a></div><div class="post_share"><div class="social-share" data-image="/null" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/10/26/Effective-Modern-Cpp4/"><img class="prev-cover" src="/null" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Effective-Modern-Cpp(4) Smart Pointers</div></div></a></div><div class="next-post pull-right"><a href="/2020/10/22/Effective-Modern-Cpp2/"><img class="next-cover" src="/null" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Effective-Modern-Cpp(2) auto</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2020/10/15/KeylessSSL/" title="Keyless SSL, The Nitty Gritty Technical Details"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-15</div><div class="title">Keyless SSL, The Nitty Gritty Technical Details</div></div></a></div><div><a href="/2020/10/11/PKCS/" title="Public-Key Cryptography Standards, PKCS"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-11</div><div class="title">Public-Key Cryptography Standards, PKCS</div></div></a></div><div><a href="/2020/10/21/Effective-Modern-Cpp1/" title="Effective Modern Cpp(1) Deducing Types"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-21</div><div class="title">Effective Modern Cpp(1) Deducing Types</div></div></a></div><div><a href="/2020/10/22/Effective-Modern-Cpp2/" title="Effective-Modern-Cpp(2) auto"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-22</div><div class="title">Effective-Modern-Cpp(2) auto</div></div></a></div><div><a href="/2020/10/26/Effective-Modern-Cpp4/" title="Effective-Modern-Cpp(4) Smart Pointers"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-26</div><div class="title">Effective-Modern-Cpp(4) Smart Pointers</div></div></a></div><div><a href="/2020/10/29/Effective-Modern-Cpp5/" title="Effective-Modern-Cpp(5) Rvalue References, Move Semantics, and Perfect Forwarding"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-29</div><div class="title">Effective-Modern-Cpp(5) Rvalue References, Move Semantics, and Perfect Forwarding</div></div></a></div></div></div></article></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By DeeEll-X</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  var script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>