<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>leetcode题解 - 1 | Enclave-X</title><meta name="keywords" content="leetcode"><meta name="author" content="DeeEll-X"><meta name="copyright" content="DeeEll-X"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="看清题目条件，数据范围。  首先排除特殊情形。  注意反复测试边界条件，防止数组越界。  多想测试用例。   20 有效的括号2022-02-09 给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&amp;#123;&#39;，&#39;&amp;#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。有效字符串需满足：左括号必须用相同">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode题解 - 1">
<meta property="og:url" content="http://deeell-x.github.io/2022/02/08/leetcode/index.html">
<meta property="og:site_name" content="Enclave-X">
<meta property="og:description" content="看清题目条件，数据范围。  首先排除特殊情形。  注意反复测试边界条件，防止数组越界。  多想测试用例。   20 有效的括号2022-02-09 给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&amp;#123;&#39;，&#39;&amp;#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。有效字符串需满足：左括号必须用相同">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://deeell-x.github.io/null">
<meta property="article:published_time" content="2022-02-08T08:53:11.000Z">
<meta property="article:modified_time" content="2022-07-15T06:47:35.234Z">
<meta property="article:author" content="DeeEll-X">
<meta property="article:tag" content="leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://deeell-x.github.io/null"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://deeell-x.github.io/2022/02/08/leetcode/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2022-07-15 14:47:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">30</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">11</div></a></div></div></div><hr/></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">1.</span> <span class="toc-text">20 有效的括号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-number">2.</span> <span class="toc-text">55 跳跃游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-number">3.</span> <span class="toc-text">56 合并区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="toc-number">4.</span> <span class="toc-text">128 最长连续序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">5.</span> <span class="toc-text">136 只出现一次的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#137-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%85%83%E7%B4%A0-2"><span class="toc-number">6.</span> <span class="toc-text">137 只出现一次的元素-2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">7.</span> <span class="toc-text">189 轮转数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="toc-number">8.</span> <span class="toc-text">977 有序数组的平方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1447-%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">1447 最简分数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1984-%E5%AD%A6%E7%94%9F%E5%88%86%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC"><span class="toc-number">10.</span> <span class="toc-text">1984 学生分数的最小差值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#283-%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="toc-number">11.</span> <span class="toc-text">283 移动零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">12.</span> <span class="toc-text">167 两数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#334-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">13.</span> <span class="toc-text">334 反转字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#557-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="toc-number">14.</span> <span class="toc-text">557 反转字符串中的单词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1020-%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">15.</span> <span class="toc-text">1020 飞地的数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-number">16.</span> <span class="toc-text">3 无重复字符的最长子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9"><span class="toc-number">17.</span> <span class="toc-text">876 链表的中间节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-number">18.</span> <span class="toc-text">19 删除链表第N个结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="toc-number">19.</span> <span class="toc-text">139 单词拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#540-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0"><span class="toc-number">20.</span> <span class="toc-text">540 有序数组中的单一元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="toc-number">21.</span> <span class="toc-text">567 字符串的排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1380-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B9%B8%E8%BF%90%E6%95%B0"><span class="toc-number">22.</span> <span class="toc-text">1380 矩阵中的幸运数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#733-%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93"><span class="toc-number">23.</span> <span class="toc-text">733 图像渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#733-%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93-1"><span class="toc-number">24.</span> <span class="toc-text">733 图像渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="toc-number">25.</span> <span class="toc-text">116 填充每一个节点的下一个右侧节点指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">26.</span> <span class="toc-text">617 合并二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1719-%E9%87%8D%E6%9E%84%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-number">27.</span> <span class="toc-text">1719 重构一棵树的方案数*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#688-%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87"><span class="toc-number">28.</span> <span class="toc-text">688 骑士在棋盘上的概率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90"><span class="toc-number">29.</span> <span class="toc-text">994 腐烂的橘子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#542-01-%E7%9F%A9%E9%98%B5"><span class="toc-number">30.</span> <span class="toc-text">542 01-矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8"><span class="toc-number">31.</span> <span class="toc-text">21 合并两个有序列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">32.</span> <span class="toc-text">206. 反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#969-%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F"><span class="toc-number">33.</span> <span class="toc-text">969 煎饼排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#77-%E7%BB%84%E5%90%88"><span class="toc-number">34.</span> <span class="toc-text">77 组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">35.</span> <span class="toc-text">70 爬楼梯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number">36.</span> <span class="toc-text">198 打家劫舍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">37.</span> <span class="toc-text">120 三角形最小路径和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E7%9A%84%E5%B9%82"><span class="toc-number">38.</span> <span class="toc-text">2的幂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D"><span class="toc-number">39.</span> <span class="toc-text">190 颠倒二进制位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#194-%E5%A5%BD%E5%AD%90%E9%9B%86%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">40.</span> <span class="toc-text">194 好子集的数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">41.</span> <span class="toc-text">33 搜索旋转数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="toc-number">42.</span> <span class="toc-text">34 在排序数组中查找元素的第一个和最后一个位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5"><span class="toc-number">43.</span> <span class="toc-text">74 搜索二维矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1706-%E7%90%83%E4%BC%9A%E8%90%BD%E4%BD%95%E5%A4%84"><span class="toc-number">44.</span> <span class="toc-text">1706 球会落何处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">45.</span> <span class="toc-text">153 寻找旋转排序数组中的最小值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#162-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC"><span class="toc-number">46.</span> <span class="toc-text">162 寻找峰值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">47.</span> <span class="toc-text">15 三数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2016-%E5%A2%9E%E9%87%8F%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC"><span class="toc-number">48.</span> <span class="toc-text">2016 增量元素之间的最大差值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">49.</span> <span class="toc-text">11 盛最多水的容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#986-%E5%8C%BA%E9%97%B4%E5%88%97%E8%A1%A8%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="toc-number">50.</span> <span class="toc-text">986 区间列表的交集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#844-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">51.</span> <span class="toc-text">844 比较含退格的字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-number">52.</span> <span class="toc-text">438 找到字符串中所有字母异位词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#713-%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8EK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">53.</span> <span class="toc-text">713 乘积小于K的子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">54.</span> <span class="toc-text">209 长度最小的子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#553-%E6%9C%80%E4%BC%98%E9%99%A4%E6%B3%95"><span class="toc-number">55.</span> <span class="toc-text">553 最优除法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1601-%E6%9C%80%E5%A4%9A%E5%8F%AF%E8%BE%BE%E6%88%90%E7%9A%84%E6%8D%A2%E6%A5%BC%E8%AF%B7%E6%B1%82%E6%95%B0%E7%9B%AE"><span class="toc-number">56.</span> <span class="toc-text">1601 最多可达成的换楼请求数目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F"><span class="toc-number">57.</span> <span class="toc-text">547 省份数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-number">58.</span> <span class="toc-text">200 岛屿数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2"><span class="toc-number">59.</span> <span class="toc-text">6 Z 字形变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-II"><span class="toc-number">60.</span> <span class="toc-text">117 填充每个节点的下一个右侧节点指针 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#572-%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91"><span class="toc-number">61.</span> <span class="toc-text">572 另一棵树的子树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#78-%E5%AD%90%E9%9B%86"><span class="toc-number">62.</span> <span class="toc-text">78. 子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#90-%E5%AD%90%E9%9B%86-II"><span class="toc-number">63.</span> <span class="toc-text">90 子集 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%E5%85%A8%E6%8E%92%E5%88%97-II"><span class="toc-number">64.</span> <span class="toc-text">47 全排列 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-number">65.</span> <span class="toc-text">39 组合总和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="toc-number">66.</span> <span class="toc-text">40 组合总和 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2104-%E5%AD%90%E6%95%B0%E7%BB%84%E8%8C%83%E5%9B%B4%E5%92%8C"><span class="toc-number">67.</span> <span class="toc-text">2104 子数组范围和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-number">68.</span> <span class="toc-text">17 电话号码的字母组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="toc-number">69.</span> <span class="toc-text">22 括号生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2100-%E9%80%82%E5%90%88%E6%89%93%E5%8A%AB%E9%93%B6%E8%A1%8C%E7%9A%84%E6%97%A5%E5%AD%90"><span class="toc-number">70.</span> <span class="toc-text">2100 适合打劫银行的日子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-II"><span class="toc-number">71.</span> <span class="toc-text">213. 打家劫舍 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II"><span class="toc-number">72.</span> <span class="toc-text">45 跳跃游戏 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-number">73.</span> <span class="toc-text">62 不同路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">74.</span> <span class="toc-text">5 最长回文子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#413-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86"><span class="toc-number">75.</span> <span class="toc-text">413 等差数列划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2055-%E8%9C%A1%E7%83%9B%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%98%E5%AD%90"><span class="toc-number">76.</span> <span class="toc-text">2055 蜡烛之间的盘子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#393-UTF-8-%E7%BC%96%E7%A0%81%E9%AA%8C%E8%AF%81"><span class="toc-number">77.</span> <span class="toc-text">393 UTF-8 编码验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#590-N-%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">78.</span> <span class="toc-text">590 N 叉树的后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#589-N-%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">79.</span> <span class="toc-text">589 N 叉树的前序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95"><span class="toc-number">80.</span> <span class="toc-text">91. 解码方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">81.</span> <span class="toc-text">300 最长递增子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#673-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">82.</span> <span class="toc-text">673 最长递增子序列的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">83.</span> <span class="toc-text">1143 最长公共子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#583-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">84.</span> <span class="toc-text">583 两个字符串的删除操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number">85.</span> <span class="toc-text">72 编辑距离</span></a></li></ol></div></div></div><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Enclave-X</a></span><span id="menus"><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">leetcode题解 - 1</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-02-08T08:53:11.000Z" title="Created 2022-02-08 16:53:11">2022-02-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-07-15T06:47:35.234Z" title="Updated 2022-07-15 14:47:35">2022-07-15</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><ol>
<li><p>看清题目条件，数据范围。</p>
</li>
<li><p>首先排除特殊情形。</p>
</li>
<li><p>注意反复测试边界条件，防止数组越界。</p>
</li>
<li><p>多想测试用例。</p>
</li>
</ol>
<h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20 有效的括号"></a>20 有效的括号</h3><p>2022-02-09</p>
<p><code>给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。</code></p>
<p>借助stack实现。</p>
<h3 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55 跳跃游戏"></a>55 跳跃游戏</h3><p>2022-02-09</p>
<p><code>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。</code></p>
<p>贪心算法：</p>
<ol>
<li><p>维护可跳到的最远距离<code>maxlength</code></p>
</li>
<li><p>遍历小于<code>maxlength</code>的数组元素，并不断更新<code>maxlength</code></p>
</li>
<li><p>若<code>maxlength</code>大于数组长度或遍历元素位置超过<code>maxlength</code>，遍历结束。</p>
</li>
</ol>
<h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56 合并区间"></a>56 合并区间</h3><p><code>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</code></p>
<p>首先对所有区间按首个元素进行排序。使用双指针合并连续范围。</p>
<h3 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128 最长连续序列"></a>128 最长连续序列</h3><p>2022-02-08</p>
<p><code>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</code></p>
<p>sol1: 哈希表记录所有数字。找出所有位于区间左侧的数字（即哈希表中不存在num-1），不断检测num+2,num+3…是否在哈希表中并更新最大区间。时间O(N),空间O(N)</p>
<h3 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136 只出现一次的数字"></a>136 只出现一次的数字</h3><p>2022-02-08</p>
<p><code>给你一个整数数组 nums ，除某个元素仅出现一次外，其余每个元素都恰出现两次。请你找出并返回那个只出现了一次的元素。</code></p>
<p>sol1: hashmap计数元素出现次数，然后遍历返回只出现一次的元素。时间O(N),空间O(N)。</p>
<p>sol2: set中存元素，set中没有就放set中，在set中存在就把set中该元素去掉。遍历后set中只存在一个元素就是所求元素。时间O(N),空间O(N)。</p>
<p>sol3: <strong>位运算中异或满足交换律和结合律。</strong>将所有元素异或，所得结果为所求元素。时间O(N),空间O(1)。</p>
<h3 id="137-只出现一次的元素-2"><a href="#137-只出现一次的元素-2" class="headerlink" title="137 只出现一次的元素-2"></a>137 只出现一次的元素-2</h3><p>2022-02-08</p>
<p><code>给你一个整数数组 nums ，除某个元素仅出现一次外，其余每个元素都恰出现三次。请你找出并返回那个只出现了一次的元素。</code></p>
<p>sol1: 同上sol1。</p>
<p>sol2: 位运算。已知给定数据范围，用一个32位数组存放各个数字的2进制和结果。所得32位数组中每一位mod 3的结果按位数将2的幂次相加即为所求元素。时间O(NlogC),空间O(1)。C为给定数据范围，此处为32。</p>
<p>sol3: 数字电路计算方法。略。</p>
<h3 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189 轮转数组"></a>189 轮转数组</h3><p>2022-02-10</p>
<p><code>给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</code></p>
<p>sol1: 借助另一个数组拷贝实现。</p>
<p>sol2: 数组翻转。原地实现轮转。首先翻转整个数组，然后以k位置为分界分别翻转左右两边。更快。</p>
<h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977 有序数组的平方"></a>977 有序数组的平方</h3><p>2022-02-10</p>
<p><code>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</code></p>
<p>sol1: 双指针，找到正负数交界位置后归并排序。</p>
<p>sol2: 双指针，分别从数组的两端开始不断将绝对值大的数的平方插入新数组（更快）。</p>
<h3 id="1447-最简分数"><a href="#1447-最简分数" class="headerlink" title="1447 最简分数"></a>1447 最简分数</h3><p>2022-02-10</p>
<p><code>给你一个整数 n ，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于  n 的 最简 分数 。分数可以以 任意 顺序返回。</code></p>
<p>遍历所有整数对<code>(i,j)(1&lt;=i&lt;j&lt;=n)</code>,判断<code>GCD(i,j)==1</code>。（欧几里得算法递归求GCD）</p>
<h3 id="1984-学生分数的最小差值"><a href="#1984-学生分数的最小差值" class="headerlink" title="1984 学生分数的最小差值"></a>1984 学生分数的最小差值</h3><p>2022-02-11</p>
<p><code>给你一个 下标从 0 开始 的整数数组 nums ，其中 nums[i] 表示第 i 名学生的分数。另给你一个整数 k 。从数组中选出任意 k 名学生的分数，使这 k 个分数间 最高分 和 最低分 的 差值 达到 最小化 。返回可能的 最小差值 。</code></p>
<p>首先对数组进行排序，然后使用k大小的滑窗计算最小差值。</p>
<h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283 移动零"></a>283 移动零</h3><p>2022-02-11</p>
<p><code>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。请注意 ，必须在不复制数组的情况下原地对数组进行操作。</code></p>
<p>双指针。总是将最左侧的0与该0后的第一个非零数进行交换。使用一遍遍历，时间复杂度O(N)。</p>
<h3 id="167-两数之和"><a href="#167-两数之和" class="headerlink" title="167 两数之和"></a>167 两数之和</h3><p>2022-02-11</p>
<p><code>给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;= index1 &lt; index2 &lt;= numbers.length 。以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。你可以假设每个输入 只对应唯一的答案 ，而且你 【不可以】 重复使用相同的元素。你所设计的解决方案必须只使用【常量级】的额外空间。</code></p>
<p>双指针。分别从数组两端开始遍历。两个指针最多遍历N个元素。时间复杂度O(N)。</p>
<h3 id="334-反转字符串"><a href="#334-反转字符串" class="headerlink" title="334 反转字符串"></a>334 反转字符串</h3><p>2022-02-12</p>
<p><code>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</code></p>
<p>双指针。分别从数组两端开始遍历并交换。</p>
<h3 id="557-反转字符串中的单词"><a href="#557-反转字符串中的单词" class="headerlink" title="557 反转字符串中的单词"></a>557 反转字符串中的单词</h3><p>2022-02-12</p>
<p><code>给定一个字符串 s ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</code></p>
<p>双指针，从0开始遍历，两指针分别指向一个单词的两端并翻转该单词顺序。</p>
<h3 id="1020-飞地的数量"><a href="#1020-飞地的数量" class="headerlink" title="1020 飞地的数量"></a>1020 飞地的数量</h3><p>2022-02-12</p>
<p><code>给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。一次 移动 是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过 grid 的边界。返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。</code></p>
<p>TODO：广搜/并查集</p>
<p>sol1: 遍历整个grid，进行深度优先搜索。将可联通的单元格标记为-1。同时更新飞地数量 - 超出时间限制。</p>
<p>sol2: 从grid的四周开始，深度优先搜索标记所有可联通的单元格为0;然后遍历整个数组，记录飞地数量。</p>
<h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3 无重复字符的最长子串"></a>3 无重复字符的最长子串</h3><p>2022-02-13</p>
<p><code>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</code></p>
<p>随着窗口左侧的递增，右侧是非递减的。使用滑动窗口+hashset实现。</p>
<h3 id="876-链表的中间节点"><a href="#876-链表的中间节点" class="headerlink" title="876 链表的中间节点"></a>876 链表的中间节点</h3><p>2022-02-13</p>
<p><code>给定一个头结点为 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。</code></p>
<p>快慢指针。慢指针每移动一个结点，快指针移动两个，直到快指针到链表末尾。</p>
<h3 id="19-删除链表第N个结点"><a href="#19-删除链表第N个结点" class="headerlink" title="19 删除链表第N个结点"></a>19 删除链表第N个结点</h3><p>2022-02-13</p>
<p><code>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</code></p>
<p>双指针，两指针之间距离为n-1，在快指针到链表末尾时删除慢指针指向结点。</p>
<h3 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139 单词拆分"></a>139 单词拆分</h3><p>2022-02-14</p>
<p><code>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</code></p>
<p>sol1: DFS。单纯DFS在实现时会发生超时，需要进行记忆化处理。原因是DFS实际上列举了所有可能的组合。TODO</p>
<p>sol2: 动态规划。可将其视作背包问题。<code>dp[i] = true</code>当且仅当存在<code>j&lt;i,dp[j]=true &amp;&amp; substr(j,i-j) in wordDict</code>。</p>
<h3 id="540-有序数组中的单一元素"><a href="#540-有序数组中的单一元素" class="headerlink" title="540 有序数组中的单一元素"></a>540 有序数组中的单一元素</h3><p>2022-02-14</p>
<p><code>给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。请你找出并返回只出现一次的那个数。你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。</code></p>
<p>O(log n)时间复杂度，即使用二分查找实现。使用位运算判断，对于出现于所求元素左侧的元素，满足<code>nums[i] == nums[i^1]</code>。</p>
<h3 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567 字符串的排列"></a>567 字符串的排列</h3><p>2022-02-14</p>
<p><code>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。换句话说，s1 的排列之一是 s2 的 子串 。</code></p>
<p>滑动窗口+hashmap，类似###3的实现。</p>
<h3 id="1380-矩阵中的幸运数"><a href="#1380-矩阵中的幸运数" class="headerlink" title="1380 矩阵中的幸运数"></a>1380 矩阵中的幸运数</h3><p>2022-02-15</p>
<p><code>给你一个 m * n 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。幸运数是指矩阵中满足同时下列两个条件的元素：在同一行的所有元素中最小; 在同一列的所有元素中最大</code></p>
<p>sol1: 对每一个元素判断是否为该行的最小元素，若是，判断是否为该列的最大元素。时间O(mn*(m+n)),空间O(1)</p>
<p>sol2: 预处理。先遍历数组记录下每一行的最小元素和每一列的最大元素。然后找它们的交集。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line">zip(list) = [([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],)([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],)]</span><br><span class="line">zip(*list) = zip([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]) = [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">6</span>]]</span><br></pre></td></tr></table></figure>

<p>sol3: 遍历每一列，找到该列的最大元素，然后用<code>all_of()</code>判断该元素是否为所在行的最小元素。时间O(n(m+n)),空间O(1)</p>
<h3 id="733-图像渲染"><a href="#733-图像渲染" class="headerlink" title="733 图像渲染"></a>733 图像渲染</h3><p>2022-02-15</p>
<p><code>有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。最后返回经过上色渲染后的图像。</code></p>
<p>若新颜色值与开始的像素值相同，直接返回。否则从初始坐标开始染色所有相连像素点</p>
<p>sol1: DFS + 递归</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(Node n, <span class="keyword">int</span> d)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (isEnd(n, d))&#123;<span class="comment">//一旦搜索深度到达一个结束状态，就返回true  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (Node nextNode in n)&#123;<span class="comment">//遍历n相邻的节点nextNode  </span></span><br><span class="line">        <span class="keyword">if</span> (!visit[nextNode])&#123;<span class="comment">//  </span></span><br><span class="line">            visit[nextNode] = <span class="literal">true</span>;<span class="comment">//在下一步搜索中，nextNode不能再次出现  </span></span><br><span class="line">            <span class="keyword">if</span> (DFS(nextNode, d+<span class="number">1</span>))&#123;<span class="comment">//如果搜索出有解  </span></span><br><span class="line">                <span class="comment">//做些其他事情，例如记录结果深度等  </span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">//重新设置成false，因为它有可能出现在下一次搜索的别的路径中  </span></span><br><span class="line">            visit[nextNode] = <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//本次搜索无解  </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>sol2: DFS + stack</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Node n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;node&gt; nodeStack;</span><br><span class="line">    nodeStack.push(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!nodeStack.empty())&#123;</span><br><span class="line">        Node node = nodeStack.top();</span><br><span class="line">        nodeStack.pop();</span><br><span class="line">        visited[node] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// DO STH</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Node nextNode in n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isEnd(nextNode) &amp;&amp; !visited[node])&#123;</span><br><span class="line">                nodeStack.push(nextNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited.reset();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>sol3: BFS(Queue)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Node n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; nodeQ;</span><br><span class="line">    nodeQ.push(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!nodeQ.empty())&#123;</span><br><span class="line">        Node node = nodeQ.front();</span><br><span class="line">        nodeQ.pop();</span><br><span class="line">        visited[node] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// DO STH</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Node nextNode in n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isEnd(nextNode) &amp;&amp; !visited[node])&#123;</span><br><span class="line">                nodeQ.push(nextNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited.reset();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="733-图像渲染-1"><a href="#733-图像渲染-1" class="headerlink" title="733 图像渲染"></a>733 图像渲染</h3><p><code>给你一个大小为 m x n 的二进制矩阵 grid 。岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。岛屿的面积是岛上值为 1 的单元格的数目。计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。</code></p>
<p>思路同#695。</p>
<h3 id="116-填充每一个节点的下一个右侧节点指针"><a href="#116-填充每一个节点的下一个右侧节点指针" class="headerlink" title="116 填充每一个节点的下一个右侧节点指针"></a>116 填充每一个节点的下一个右侧节点指针</h3><p>2022-02-16</p>
<p><code>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sol1: 广度优先搜索。使用队列，处理每一层的节点，并不断将该节点的左右节点放入队列。</p>
<p>sol2: 对每一层的节点，记录最左侧节点的左子节点，然后处理该层每个节点的左右子节点（node-&gt;left-&gt;next = node-&gt;right; node-&gt;right-&gt;next = node-&gt;next-&gt;left;)，层层迭代。此时不需要额外空间。</p>
<h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617 合并二叉树"></a>617 合并二叉树</h3><p>2022-02-16</p>
<p><code>给你两棵二叉树： root1 和 root2 。想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。返回合并后的二叉树。注意: 合并过程必须从两个树的根节点开始。</code></p>
<p>sol1: 递归</p>
<p>sol2: 广度优先搜索，使用三个队列，分别放root1、root2两棵树的节点和新构造的节点。</p>
<h3 id="1719-重构一棵树的方案数"><a href="#1719-重构一棵树的方案数" class="headerlink" title="1719 重构一棵树的方案数*"></a>1719 重构一棵树的方案数*</h3><p>2022-02-16</p>
<blockquote>
<p>给你一个数组 pairs ，其中 pairs[i] = [xi, yi] ，并且满足：<br>pairs 中没有重复元素<br>xi &lt; yi<br>令 ways 为满足下面条件的有根树的方案数：<br>树所包含的所有节点值都在 pairs 中。<br>一个数对 [xi, yi] 出现在 pairs 中 当且仅当 xi 是 yi 的祖先或者 yi 是 xi 的祖先。<br>注意：构造出来的树不一定是二叉树。<br>两棵树被视为不同的方案当存在至少一个节点在两棵树中有不同的父节点。<br>请你返回：<br>如果 ways == 0 ，返回 0 。<br>如果 ways == 1 ，返回 1 。<br>如果 ways &gt; 1 ，返回 2 。<br>一棵 有根树 指的是只有一个根节点的树，所有边都是从根往外的方向。<br>我们称从根到一个节点路径上的任意一个节点（除去节点本身）都是该节点的 祖先 。根节点没有祖先。</p>
</blockquote>
<p>记<code>degree(node) = count(pair for pair in pairs if node in pair)</code>对于一棵树：</p>
<ol>
<li><p>degree(root) = count(nodes) - 1(即root与所有节点相连)</p>
</li>
<li><p>若node1是node2的祖先节点，必有<code>degree(node1)&gt;=degree(node2)</code>，且<code>adjacents[node2] in adjacents[node1]</code></p>
</li>
<li><p>若存在(node1,node2)，且<code>degree(node1)==degree(node2)</code>则node1，node2位置可交换，即树存在不同方案</p>
</li>
</ol>
<p>sol：</p>
<ol>
<li><p>记录每个节点的子节点和祖先节点</p>
</li>
<li><p>判断degree(root) == count(nodes) - 1</p>
</li>
<li><p>遍历所有非根节点，找到与该节点相连的度数最小的节点，判断<code>adjacents[node2] in adjacents[node1]</code>,若不满足则ways = 0</p>
</li>
<li><p>若上述找到的节点满足<code>degree(node1) == degree(node2)</code>, 那么ways = 2</p>
</li>
</ol>
<h3 id="688-骑士在棋盘上的概率"><a href="#688-骑士在棋盘上的概率" class="headerlink" title="688 骑士在棋盘上的概率"></a>688 骑士在棋盘上的概率</h3><blockquote>
<p>在一个 n x n 的国际象棋棋盘上，一个骑士从单元格 (row, column) 开始，并尝试进行 k 次移动。行和列是 从 0 开始 的，所以左上单元格是 (0,0) ，右下单元格是 (n - 1, n - 1) 。<br>象棋骑士有8种可能的走法。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。<br>每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。<br>骑士继续移动，直到它走了 k 步或离开了棋盘。<br>返回 骑士在棋盘停止移动后仍留在棋盘上的概率 。</p>
</blockquote>
<p>sol1: 暴力求解所有可能的结果（BFS/DFS），但是时间开销较大。</p>
<p>sol2: BFS+记忆化搜索。使用<code>dp[k][i][j]</code>记录i,j出发进行k次移动还位于棋盘的概率。</p>
<p>sol3: 动态规划。利用前面记忆化搜索的思路，分配<code>dp[k+1][n][n]</code>大小的数组，其中<code>dp[0][i][j]=1</code>。<code>dp[k][i][j] = SumOfDirs(dp[k-1][i+dir.x][j+dir.y])/8</code></p>
<h3 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994 腐烂的橘子"></a>994 腐烂的橘子</h3><blockquote>
<p>在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：<br>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。<br>返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。</p>
</blockquote>
<p>sol: BFS。记录轮次。</p>
<h3 id="542-01-矩阵"><a href="#542-01-矩阵" class="headerlink" title="542 01-矩阵"></a>542 01-矩阵</h3><blockquote>
<p>给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。<br>两个相邻元素间的距离为 1 。</p>
</blockquote>
<p>sol1: BFS。可用#994的解决方法，从所有的0出发，一步步“污染”1，元素的值为“污染”的轮次。</p>
<p>sol2: DP。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!mat[x][y])</span><br><span class="line">    f(x,y) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    f(x,y) = min(f(x<span class="number">-1</span>,y),f(x,y<span class="number">-1</span>),f(x+<span class="number">1</span>,y),f(x,y+<span class="number">1</span>))+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="21-合并两个有序列表"><a href="#21-合并两个有序列表" class="headerlink" title="21 合并两个有序列表"></a>21 合并两个有序列表</h3><blockquote>
<p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
</blockquote>
<p>sol1: 插入排序。</p>
<p>sol2: 递归。</p>
<h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h3><blockquote>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。<br>即将所有节点的next指针反向。</p>
</blockquote>
<p>sol1: 迭代，记录prev指针,cur指针和next指针，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">next = cur-&gt;next;</span><br><span class="line">cur-&gt;next = prev;</span><br><span class="line">prev = cur; </span><br><span class="line">cur = next;</span><br></pre></td></tr></table></figure>

<p>sol2: 递归。注意递归返回最后一个非NULL指针。</p>
<h3 id="969-煎饼排序"><a href="#969-煎饼排序" class="headerlink" title="969 煎饼排序"></a>969 煎饼排序</h3><p>2022-02-19</p>
<blockquote>
<p>给你一个整数数组 arr ，请使用 煎饼翻转 完成对数组的排序。<br>一次煎饼翻转的执行过程如下：<br>选择一个整数 k ，1 &lt;= k &lt;= arr.length<br>反转子数组 arr[0…k-1]（下标从 0 开始）<br>例如，arr = [3,2,1,4] ，选择 k = 3 进行一次煎饼翻转，反转子数组 [3,2,1] ，得到 arr = [1,2,3,4] 。<br>以数组形式返回能使 arr 有序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * arr.length 范围内的有效答案都将被判断为正确。</p>
</blockquote>
<p>sol:从n-1开始不断将元素换到最后。[i1,i2,…,ia = k,…ib,k+1,k+2,…,n-1]经历两次变换，第一次为a，将k换到数组头部，第二次为b，k换到k+1前。</p>
<h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77 组合"></a>77 组合</h3><p>2022-02-19</p>
<blockquote>
<p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。<br>你可以按 任何顺序 返回答案。</p>
</blockquote>
<p>sol:全排列问题。按序选择k个数即可。</p>
<h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70 爬楼梯"></a>70 爬楼梯</h3><p>2022-02-20</p>
<blockquote>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
</blockquote>
<p>sol：动态规划。<code>s[i] = s[i-2]+s[i-1]</code>。</p>
<h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198 打家劫舍"></a>198 打家劫舍</h3><p>2022-02-20</p>
<blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
</blockquote>
<p>sol: 记dp[i]为前i个房间能够偷窃到的最高金额，<code>dp[i]=max(dp[i−2]+nums[i],dp[i−1])</code></p>
<h3 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120 三角形最小路径和"></a>120 三角形最小路径和</h3><p>2022-02-20</p>
<blockquote>
<p>给定一个三角形 triangle ，找出自顶向下的最小路径和。<br>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p>
</blockquote>
<p>sol:对应vec[i][j]为经过i，j位置的最小路径，有<code>vec[i][j] = min(vec[i-1][j],vec[i-1][j-1])+triangle[i][j]</code></p>
<h3 id="2的幂"><a href="#2的幂" class="headerlink" title="2的幂"></a>2的幂</h3><p>2022-02-21</p>
<blockquote>
<p>给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。<br>如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。</p>
</blockquote>
<p>sol1: <code>n&gt;0 &amp;&amp; n&amp;(n-1) == 0</code></p>
<p>sol2: <code>n&gt;0 &amp;&amp; (1&lt;&lt;30)%n ==0</code></p>
<h3 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190 颠倒二进制位"></a>190 颠倒二进制位</h3><p>2022-02-22</p>
<blockquote>
<p>颠倒给定的 32 位无符号整数的二进制位。</p>
</blockquote>
<p>sol1: 遍历所有的位，使用位运算。</p>
<p>sol2: divide-and-conquer。颠倒一个32位的int，需要分别颠倒前16-后16位，8-8位，4-4位，2-2位</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n = (n &gt;&gt; <span class="number">1</span> &amp; <span class="number">0x55555555</span>) | (n &amp; <span class="number">0x55555555</span>) &lt;&lt;<span class="number">1</span>;</span><br><span class="line">n = (n &gt;&gt; <span class="number">2</span> &amp; <span class="number">0x33333333</span>) | (n &amp; <span class="number">0x33333333</span>) &lt;&lt;<span class="number">1</span>;</span><br><span class="line">n = (n &gt;&gt; <span class="number">4</span> &amp; <span class="number">0x0f0f0f0f</span>) | (n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt;<span class="number">1</span>;</span><br><span class="line">n = (n &gt;&gt; <span class="number">8</span> &amp; <span class="number">0x00ff00ff</span>) | (n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt;<span class="number">1</span>;</span><br><span class="line">n = n&gt;&gt;<span class="number">16</span> | n&lt;&lt;<span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<h3 id="194-好子集的数目"><a href="#194-好子集的数目" class="headerlink" title="194 好子集的数目"></a>194 好子集的数目</h3><p>2022-02-22</p>
<blockquote>
<p>给你一个整数数组 nums 。如果 nums 的一个子集中，所有元素的乘积可以表示为一个或多个 互不相同的质数 的乘积，那么我们称它为 好子集 。<br>    比方说，如果 nums = [1, 2, 3, 4] ：<br>    [2, 3] ，[1, 2, 3] 和 [1, 3] 是 好 子集，乘积分别为 6 = 2*3 ，6 = 2*3 和 3 = 3 。<br>    [1, 4] 和 [4] 不是 好 子集，因为乘积分别为 4 = 2*2 和 4 = 2*2 。<br>    请你返回 nums 中不同的 好 子集的数目对 10^9 + 7 取余 的结果。<br>nums 中的 子集 是通过删除 nums 中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。<br>提示：<br>1 &lt;= nums.length &lt;= 105<br>1 &lt;= nums[i] &lt;= 30</p>
</blockquote>
<p>sol: 已知所有数在[1,30]，[1,30]范围内的质数有primes[]=[2,3,5,7,11,13,17,19,23,27,29]。首先剔除掉nums中的<code>[4,8,12,16,20,24,28,9,18,27,25]</code>。将nums中的1也剔除，分开来单独考虑。新的数组new_num，统计其中所有数字和出现频率放入一个<code>map&lt;num,counts&gt; countmap</code>。</p>
<ol>
<li><p>对于任何好子集，添加任意个1仍然是好子集。统计得到的好子集数为<code>ans*1&lt;&lt;counts[1]</code>。</p>
</li>
<li><p>使用动态规划。设计数组dp[1&lt;&lt;10],dp[product]product的二进制表示的第i位表示primes[i]为product的因子。<code>dp[1] = 1</code>。遍历countmap中的所有数<code>[num,counts]</code>，得到num的因子分解后的二进制位binum。对任意i且<code>i&amp;binum == 0</code>有<code>dp[i|binum] = dp[i|binum] + dp[i] *counts</code></p>
</li>
</ol>
<h3 id="33-搜索旋转数组"><a href="#33-搜索旋转数组" class="headerlink" title="33 搜索旋转数组"></a>33 搜索旋转数组</h3><blockquote>
<p>整数数组 nums 按升序排列，数组中的值 互不相同 。<br>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。<br>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
</blockquote>
<p>sol: 二分查找。需要区分左侧有序和右侧有序时左右指针的处理。</p>
<h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34 在排序数组中查找元素的第一个和最后一个位置"></a>34 在排序数组中查找元素的第一个和最后一个位置</h3><p>2022-02-23</p>
<blockquote>
<p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。<br>如果数组中不存在目标值 target，返回 [-1, -1]。<br>进阶：<br>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</p>
</blockquote>
<p>sol1: <code>std::equal_range(nums.begin(), nums.end(), target)</code>直接得到范围，处理后返回即可。</p>
<p>sol2: 使用两次二分查找，分别找出目标范围的左右边界。</p>
<h3 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74 搜索二维矩阵"></a>74 搜索二维矩阵</h3><p>2022-02-23</p>
<blockquote>
<p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：<br>每行中的整数从左到右按升序排列。<br>每行的第一个整数大于前一行的最后一个整数。</p>
</blockquote>
<p>sol1：显然col方向上值下降最快。两个方向上查找，首先找到目标值所在行，然后在行中确认目标值是否存在即可。<br>查找方式可用<code>std::upperbound()</code>和<code>binary_search()</code></p>
<p>sol2: 可知一行最右侧元素小于下行最左侧元素，可对整个矩阵进行二分查找，<code>index = col*(index/col) + index%col</code></p>
<h3 id="1706-球会落何处"><a href="#1706-球会落何处" class="headerlink" title="1706 球会落何处"></a>1706 球会落何处</h3><p>2022-02-24</p>
<blockquote>
<p>用一个大小为 m x n 的二维网格 grid 表示一个箱子。你有 n 颗球。箱子的顶部和底部都是开着的。<br>箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。<br>将球导向右侧的挡板跨过左上角和右下角，在网格中用 1 表示。<br>将球导向左侧的挡板跨过右上角和左下角，在网格中用 -1 表示。<br>在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的 “V” 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。<br>返回一个大小为 n 的数组 answer ，其中 answer[i] 是球放在顶部的第 i 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 -1 。</p>
</blockquote>
<p>sol： 模拟每个小球的运行路径，若两个挡板相接或碰到墙，返回-1。时间复杂度<code>O(NM)</code>。</p>
<h3 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153 寻找旋转排序数组中的最小值"></a>153 寻找旋转排序数组中的最小值</h3><p>2022-02-24</p>
<blockquote>
<p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]<br>若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。<br>给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p>
</blockquote>
<p>sol: 二分查找。</p>
<ol>
<li><p>若<code>left&lt;mid&lt;right</code>，返回左半边数组。</p>
</li>
<li><p>若<code>mid&gt;left &amp;&amp; mid &gt; right</code>，返回右半边数组。</p>
</li>
<li><p>若<code>mid&lt; left &amp;&amp; mid &lt; right</code>,返回左半边数组。</p>
</li>
</ol>
<p>结合上述条件，仅当<code>mid&gt;right</code>时返回右半边数组，否则返回左半边数组。直到两个指针相等即可。</p>
<h3 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162 寻找峰值"></a>162 寻找峰值</h3><p>2022-02-24</p>
<blockquote>
<p>峰值元素是指其值严格大于左右相邻值的元素。<br>给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。<br>你可以假设 nums[-1] = nums[n] = -∞ 。<br>你必须实现时间复杂度为 O(log n) 的算法来解决此问题。</p>
</blockquote>
<p>sol: 二分查找。首先必定存在一个这样的元素。然后看<code>nums[mid] &gt; nums[mid+1]</code>是否满足，若满足，则返回左半边数组，若不满足，返回右半边数组。</p>
<h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15 三数之和"></a>15 三数之和</h3><p>2022-02-25</p>
<blockquote>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。</p>
</blockquote>
<p>sol:排序+ 双指针。</p>
<ol>
<li><p>注意不可以包含重复的三元组。首元素的选择和双指针的移动要跳过重复元素。</p>
</li>
<li><p>跳过重复元素的时候要注意是否发生数组越界。</p>
</li>
</ol>
<h3 id="2016-增量元素之间的最大差值"><a href="#2016-增量元素之间的最大差值" class="headerlink" title="2016 增量元素之间的最大差值"></a>2016 增量元素之间的最大差值</h3><p>2022-02-26</p>
<blockquote>
<p>给你一个下标从 0 开始的整数数组 nums ，该数组的大小为 n ，请你计算 nums[j] - nums[i] 能求得的 最大差值 ，其中 0 &lt;= i &lt; j &lt; n 且 nums[i] &lt; nums[j] 。<br>返回 最大差值 。如果不存在满足要求的 i 和 j ，返回 -1 。</p>
</blockquote>
<p>sol：前缀最小值法，记录前缀的最小值并更新差值。</p>
<h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11 盛最多水的容器"></a>11 盛最多水的容器</h3><p>2022-02-26</p>
<blockquote>
<p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。<br>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>返回容器可以储存的最大水量。<br>说明：你不能倾斜容器。</p>
</blockquote>
<p>sol： 双指针法。左右指针分别从数组的两端开始，height较小的指针向中心移动，直到新的height比原先大。如此不断比较更新计算的存储最大水量，直到两个指针相遇。</p>
<h3 id="986-区间列表的交集"><a href="#986-区间列表的交集" class="headerlink" title="986 区间列表的交集"></a>986 区间列表的交集</h3><p>2022-02-26</p>
<blockquote>
<p>给定两个由一些 闭区间 组成的列表，firstList 和 secondList ，其中 firstList[i] = [starti, endi] 而 secondList[j] = [startj, endj] 。每个区间列表都是成对 不相交 的，并且 已经排序 。<br>返回这 两个区间列表的交集 。<br>形式上，闭区间 [a, b]（其中 a &lt;= b）表示实数 x 的集合，而 a &lt;= x &lt;= b 。<br>两个闭区间的 交集 是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3] 。</p>
</blockquote>
<p>sol: 两个列表各设置一指针，初始时刻指向两个列表的头部。不断比较指针指向闭区间的左侧最大值和右侧最小值，若有交集，将交集加入返回区间列表，并将右侧较小的列表的指针++。直到其中一个指针指向列表尾部。</p>
<h3 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844 比较含退格的字符串"></a>844 比较含退格的字符串</h3><p>2022-02-26</p>
<blockquote>
<p>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。<br>注意：如果对空文本输入退格字符，文本继续为空。</p>
</blockquote>
<p>sol1: 栈。重新构建字符串并比较。</p>
<p>sol2: 双指针。从两个字符串的尾部开始，循环处理退格字符并逐字符比较处理后的字符串。</p>
<h3 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438 找到字符串中所有字母异位词"></a>438 找到字符串中所有字母异位词</h3><p>2022-02-27</p>
<blockquote>
<p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。<br>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）</p>
</blockquote>
<p>sol: 滑动窗口 + hashmap 类似 ###567的实现。</p>
<h3 id="713-乘积小于K的子数组"><a href="#713-乘积小于K的子数组" class="headerlink" title="713 乘积小于K的子数组"></a>713 乘积小于K的子数组</h3><p>2022-02-27</p>
<blockquote>
<p>给定一个正整数数组 nums和整数 k 。<br>请找出该数组内乘积小于 k 的连续的子数组的个数。</p>
</blockquote>
<p>sol: 滑动窗口，对于右侧固定的窗口来说，随着左侧的递增，乘积单调不增。故每次先移动右侧窗口到乘积小于k的最右侧，然后将左侧窗口向前移动一位，并添加right-left个结果；如此循环直到左侧窗口到数组尾部。</p>
<h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209 长度最小的子数组"></a>209 长度最小的子数组</h3><p>2022-02-27</p>
<blockquote>
<p>给定一个含有 n 个正整数的数组和一个正整数 target 。<br>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
</blockquote>
<p>sol: 滑动窗口，对于右侧固定的窗口来说，随着左侧的递增，乘积单调递减。O(n)用滑动窗口遍历整个数组，并记录滑动过程中子数组的最小长度。</p>
<h3 id="553-最优除法"><a href="#553-最优除法" class="headerlink" title="553 最优除法"></a>553 最优除法</h3><blockquote>
<p>给定一组正整数，相邻的整数之间将会进行浮点除法操作。例如， [2,3,4] -&gt; 2 / 3 / 4 。<br>但是，你可以在任意位置添加任意数目的括号，来改变算数的优先级。你需要找出怎么添加括号，才能得到最大的结果，并且返回相应的字符串格式的表达式。你的表达式不应该含有冗余的括号。</p>
</blockquote>
<p>sol: 数学 + 贪心。无论什么组合，化为分式，ele[0]总在分子，ele[1]总在分母。要尽可能让其他元素在化为分式时处于分母位置：只有一种解法，就是<code>ele[0]/(ele[1]/ele[2]/.../ele[n])</code>。</p>
<h3 id="1601-最多可达成的换楼请求数目"><a href="#1601-最多可达成的换楼请求数目" class="headerlink" title="1601 最多可达成的换楼请求数目"></a>1601 最多可达成的换楼请求数目</h3><p>2022-02-28</p>
<blockquote>
<p>我们有 n 栋楼，编号从 0 到 n - 1 。每栋楼有若干员工。由于现在是换楼的季节，部分员工想要换一栋楼居住。<br>给你一个数组 requests ，其中 requests[i] = [fromi, toi] ，表示一个员工请求从编号为 fromi 的楼搬到编号为 toi 的楼。<br>一开始 所有楼都是满的，所以从请求列表中选出的若干个请求是可行的需要满足 每栋楼员工净变化为 0 。意思是每栋楼 离开 的员工数目 等于 该楼 搬入 的员工数数目。比方说 n = 3 且两个员工要离开楼 0 ，一个员工要离开楼 1 ，一个员工要离开楼 2 ，如果该请求列表可行，应该要有两个员工搬入楼 0 ，一个员工搬入楼 1 ，一个员工搬入楼 2 。<br>请你从原请求列表中选出若干个请求，使得它们是一个可行的请求列表，并返回所有可行列表中最大请求数目。</p>
</blockquote>
<p>sol: 求不成环的最少请求数目。可成任意个环。已知请求列表长度有限，枚举每一种可能，判断是否每栋楼in == out，并更新最大数量。</p>
<h3 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547 省份数量"></a>547 省份数量</h3><p>2022-02-28</p>
<blockquote>
<p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。<br>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。<br>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。<br>返回矩阵中 省份 的数量。</p>
</blockquote>
<p>sol: 广搜/深搜。记录并更新数量。</p>
<h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200 岛屿数量"></a>200 岛屿数量</h3><p>2022-02-28</p>
<p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。</p>
<p>sol: 广搜/深搜。同###548。</p>
<h3 id="6-Z-字形变换"><a href="#6-Z-字形变换" class="headerlink" title="6 Z 字形变换"></a>6 Z 字形变换</h3><p>2022-03-01</p>
<blockquote>
<p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。<br>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：<br>P   A   H   N<br>A P L S I I G<br>Y   I   R<br>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p>
</blockquote>
<p>sol：模拟。</p>
<ol>
<li><p>开辟一个<code>vector&lt;string&gt;(numRows,&quot;&quot;)</code>,遍历s中的每个字符并加到对应的字符串后，然后拼接字符串。</p>
</li>
<li><p>不断向字符串尾部添加对应位置的字符，首先是<code>i*(2*numRows-2)</code>,然后是<code>row+i*(2*numRows-2)</code>,<code>(i+1)*(2*numRows-2)-row</code>,最后是<code>row + i*(2*numRows-2)</code>。返回字符串。时间复杂度O(n),空间复杂度O(1)。</p>
</li>
</ol>
<h3 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117 填充每个节点的下一个右侧节点指针 II"></a>117 填充每个节点的下一个右侧节点指针 II</h3><p>2022-03-01</p>
<blockquote>
<p>给定一个二叉树<br>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>初始状态下，所有 next 指针都被设置为 NULL。</p>
</blockquote>
<p>sol1: BFS。层层遍历。</p>
<p>sol2: 递归。递归处理每个节点的左右节点。</p>
<h3 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572 另一棵树的子树"></a>572 另一棵树的子树</h3><p>2022-03-01</p>
<blockquote>
<p>给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。<br>二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。</p>
</blockquote>
<p>sol：递归，判断每个节点和左右子树是否相等。</p>
<h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h3><p>2022-03-03</p>
<blockquote>
<p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。<br>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p>
</blockquote>
<p>sol：假设N个元素，共有2^N个子集。遍历1-2^N，每一个数代表一个子集，每一个bit代表数组对应位置的数字在该<br>子集中是否存在。返回结果</p>
<h3 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90 子集 II"></a>90 子集 II</h3><p>2022-03-03</p>
<blockquote>
<p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。<br>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p>
</blockquote>
<p>sol：同上面的思路，但要去重。首先将所有元素进行排序。遍历1-2^N，每一个数代表一个子集，若第N个bit为1，第N-1个bit为0且两个bit代表的数相等，此时说明已经存在相同的子集，需要跳过。<br>也就是说，对于当前选择的数 x，若前面有与其相同的数 y，且没有选择 y，此时包含 x 的子集，必然会出现在包含 y 的所有子集中。</p>
<h3 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47 全排列 II"></a>47 全排列 II</h3><p>2022-03-04</p>
<blockquote>
<p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p>
</blockquote>
<p>sol: 对数组从0-n依次填入数字，对于任意位置，遍历nums，对于<code>nums[i]</code>且<code>nums[i]==nums[i-1]</code>说明相同的数字曾经填入过，跳过。一旦填入<code>nums[k]</code>就将<code>nums[k]</code>置为11，递归调用后将数字恢复。</p>
<h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39 组合总和"></a>39 组合总和</h3><p>2022-03-04</p>
<blockquote>
<p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。<br>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。<br>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p>
</blockquote>
<p>sol: 递归。思路同全排列。</p>
<h3 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40 组合总和 II"></a>40 组合总和 II</h3><p>2022-03-04</p>
<blockquote>
<p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的每个数字在每个组合中只能使用 一次 。<br>注意：解集不能包含重复的组合。 </p>
</blockquote>
<p>sol: 与39区别在于40中的集合中元素可能重复且每个数字只能使用一次。思路同47，对于对于<code>nums[i]</code>且<code>nums[i]==nums[i-1]</code>说明相同的数字曾经填入过，跳过。</p>
<h3 id="2104-子数组范围和"><a href="#2104-子数组范围和" class="headerlink" title="2104 子数组范围和"></a>2104 子数组范围和</h3><p>2022-03-05</p>
<blockquote>
<p>给你一个整数数组 nums 。nums 中，子数组的 范围 是子数组中最大元素和最小元素的差值。<br>返回 nums 中 所有 子数组范围的 和 。<br>子数组是数组中一个连续 非空 的元素序列。</p>
</blockquote>
<p>sol1: 遍历所有子数组求解。</p>
<p>sol2: 单调栈，分别求出一个元素为最大值和最小值的数组范围并求和。</p>
<h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17 电话号码的字母组合"></a>17 电话号码的字母组合</h3><p>2022-03-05</p>
<blockquote>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
</blockquote>
<p>sol: permutation。</p>
<h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22 括号生成"></a>22 括号生成</h3><p>2022-03-05</p>
<blockquote>
<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
</blockquote>
<p>sol: permutation。记录某一位置已填入的左括号和右括号的数量后做递归。</p>
<h3 id="2100-适合打劫银行的日子"><a href="#2100-适合打劫银行的日子" class="headerlink" title="2100 适合打劫银行的日子"></a>2100 适合打劫银行的日子</h3><p>2022-03-06</p>
<blockquote>
<p>你和一群强盗准备打劫银行。给你一个下标从 0 开始的整数数组 security ，其中 security[i] 是第 i 天执勤警卫的数量。日子从 0 开始编号。同时给你一个整数 time 。<br>如果第 i 天满足以下所有条件，我们称它为一个适合打劫银行的日子：<br>第 i 天前和后都分别至少有 time 天。<br>第 i 天前连续 time 天警卫数目都是非递增的。<br>第 i 天后连续 time 天警卫数目都是非递减的。<br>更正式的，第 i 天是一个合适打劫银行的日子当且仅当：<code>security[i - time] &gt;= security[i - time + 1] &gt;= ... &gt;= security[i] &lt;= ... &lt;= security[i + time - 1] &lt;= security[i + time]</code>.<br>请你返回一个数组，包含 所有 适合打劫银行的日子（下标从 0 开始）。返回的日子可以 任意 顺序排列。</p>
</blockquote>
<p>sol: 遍历数组两次，分别记录下每一天之前警卫非递增的天数和每一天之后警卫非递减的天数。然后统计满足题目要求的天数。</p>
<h3 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a>213. 打家劫舍 II</h3><p>2022-03-06</p>
<blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p>
</blockquote>
<p>sol: 动态规划。<code>rob[i] = max(rob[i-1],rob[i-2]+nums[i])</code>。由于第一个房屋和最后一个相连，需要遍历做动态规划两次，一次是1～size-2，一次是2～size-1。</p>
<h3 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45 跳跃游戏 II"></a>45 跳跃游戏 II</h3><p>2022-03-07</p>
<blockquote>
<p>给你一个非负整数数组 nums ，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>你的目标是使用最少的跳跃次数到达数组的最后一个位置。<br>假设你总是可以到达数组的最后一个位置。</p>
</blockquote>
<p>sol: 贪心算法，同44，区别在于需要记录能跳到的最远位置的次数。</p>
<h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62 不同路径"></a>62 不同路径</h3><p>2022-03-07</p>
<blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br>问总共有多少条不同的路径？</p>
</blockquote>
<p>sol1: 共行m+n-2个格子，其中m-1次向右，n-1次向下。排列组合方式计算即可。</p>
<p>sol2：动态规划。<code>a[i][j] = a[i-1][j]+a[i][j-1]</code>,使用迭代式的数组计算可以将空间复杂度降到<code>O(min(m,n))</code>。</p>
<h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5 最长回文子串"></a>5 最长回文子串</h3><p>2022-03-08</p>
<blockquote>
<p>给你一个字符串 s，找到 s 中最长的回文子串。</p>
</blockquote>
<p>sol1: 中心扩展算法，遍历每个字符，计算以该字符为中心/<code>str[i]</code>与<code>str[i+1]</code>为中心的最长回文子串。</p>
<p>sol2: 动态规划，用一个 <code>dp[s.length()][s.length()]</code>记录[i,j]是否为回文子串。其中<code>dp[i][i] = true</code>, <code>dp[i][i+1] = str[i]==str[i+1]</code>,<code>dp[i][j] = dp[i+1][j-1] &amp;&amp; str[i] == str[j]</code>。遍历长度为2-maxlen的所有回文子串。</p>
<h3 id="413-等差数列划分"><a href="#413-等差数列划分" class="headerlink" title="413 等差数列划分"></a>413 等差数列划分</h3><p>2022-03-08</p>
<blockquote>
<p>如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。<br>例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。<br>给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。<br>子数组 是数组中的一个连续序列。</p>
</blockquote>
<p>sol: 动态规划，若<code>dp[i]-dp[i-1]==lastdiff</code>, <code>dp[i] = dp[i-1] + i-lastpos-1</code>;否则<code>lastdiff=dp[i]-dp[i-1]</code>, <code>lastpos = i-1</code>。</p>
<h3 id="2055-蜡烛之间的盘子"><a href="#2055-蜡烛之间的盘子" class="headerlink" title="2055 蜡烛之间的盘子"></a>2055 蜡烛之间的盘子</h3><p>2022-03-08</p>
<blockquote>
<p>给你一个长桌子，桌子上盘子和蜡烛排成一列。给你一个下标从 0 开始的字符串 s ，它只包含字符 ‘<em>‘ 和 ‘|’ ，其中 ‘</em>‘ 表示一个 盘子 ，’|’ 表示一支 蜡烛 。<br>同时给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [lefti, righti] 表示 子字符串 s[lefti…righti] （包含左右端点的字符）。对于每个查询，你需要找到 子字符串中 在 两支蜡烛之间 的盘子的 数目 。如果一个盘子在 子字符串中 左边和右边 都 至少有一支蜡烛，那么这个盘子满足在 两支蜡烛之间 。<br>比方说，s = “||<strong>||</strong>|<em>“ ，查询 [3, 8] ，表示的是子字符串 “</em>||**|” 。子字符串中在两支蜡烛之间的盘子数目为 2 ，子字符串中右边两个盘子在它们左边和右边 都 至少有一支蜡烛。<br>请你返回一个整数数组 answer ，其中 answer[i] 是第 i 个查询的答案。</p>
</blockquote>
<p>sol: 预处理+前缀和。记录每个蜡烛前的所有盘子数目。为了防止超时，用一个数组记录位于每个位置或左侧最近的蜡烛；用一个数组记录位于每个位置或右侧最近的蜡烛。然后遍历所有query，计算对应的盘子数目。</p>
<h3 id="393-UTF-8-编码验证"><a href="#393-UTF-8-编码验证" class="headerlink" title="393 UTF-8 编码验证"></a>393 UTF-8 编码验证</h3><p>2022-03-13</p>
<blockquote>
<p>给定一个表示数据的整数数组 data ，返回它是否为有效的 UTF-8 编码。<br>UTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则：<br>对于 1 字节 的字符，字节的第一位设为 0 ，后面 7 位为这个符号的 unicode 码。<br>对于 n 字节 的字符 (n &gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。<br>这是 UTF-8 编码的工作方式：<br>   Char. number range  |        UTF-8 octet sequence<br>      (hexadecimal)    |              (binary)<br>   ——————–+———————————————<br>   0000 0000-0000 007F | 0xxxxxxx<br>   0000 0080-0000 07FF | 110xxxxx 10xxxxxx<br>   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx<br>   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx<br>注意：输入是整数数组。只有每个整数的 最低 8 个有效位 用来存储数据。这意味着每个整数只表示 1 字节的数据。</p>
</blockquote>
<p>sol: 遍历+位运算，考察每个可能的utf8字节开头，验证对应的字符。</p>
<h3 id="590-N-叉树的后序遍历"><a href="#590-N-叉树的后序遍历" class="headerlink" title="590 N 叉树的后序遍历"></a>590 N 叉树的后序遍历</h3><p>2022-03-13</p>
<blockquote>
<p>给定一个 n 叉树的根节点 root ，返回 其节点值的 后序遍历 。<br>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</p>
</blockquote>
<p>sol1: 递归处理每个节点的子节点后，将该节点的值放入返回数组。</p>
<p>sol2: 迭代处理。先将root节点放入栈，在栈非空且栈顶节点子节点数组非空时循环倒序push所有栈顶节点的子节点，直至遇到n叉树的叶子结点，并将叶子结点的值放入返回数组。其中需要考虑n叉树中的节点的子节点被多次放入返回数组的情况，使用unordered_set防止重复。</p>
<h3 id="589-N-叉树的前序遍历"><a href="#589-N-叉树的前序遍历" class="headerlink" title="589 N 叉树的前序遍历"></a>589 N 叉树的前序遍历</h3><p>2022-03-13</p>
<blockquote>
<p>给定一个 n 叉树的根节点  root ，返回 其节点值的 前序遍历 。<br>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</p>
</blockquote>
<p>sol1: 递归。将节点的值放入返回数组后递归处理子节点数组。</p>
<p>sol2: 迭代处理。借助栈，每次循环将栈顶节点值放入返回数组后，pop栈顶元素，并倒序push子节点数组入栈，直至栈为空。</p>
<h3 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a>91. 解码方法</h3><p>2022-03-14</p>
<blockquote>
<p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：<br>‘A’ -&gt; “1”<br>‘B’ -&gt; “2”<br>…<br>‘Z’ -&gt; “26”<br>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：<br>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)<br>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。<br>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。<br>题目数据保证答案肯定是一个 32 位 的整数。</p>
</blockquote>
<p>sol: 动态规划。初始化dp数组为消息的长度+1，其中<code>dp[i] = 0</code>,<code>dp[0] = 1</code>。若第i位字符为’1’-‘9’，<code>dp[i] += dp[i-1]</code>。若第i位字符和第i-1位字符构成10-26，<code>dp[i]+=dp[i-2]</code>。</p>
<h3 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300 最长递增子序列"></a>300 最长递增子序列</h3><p>2022-03-14</p>
<blockquote>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。<br>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
</blockquote>
<p>sol: 动态规划，数组<code>dp(len)</code>记录每个以每个元素结尾的最长子序列长度<code>dp[i] = max(dp[j]+1)(j&lt;i,nums[j]&lt;nums[i]</code>。返回dp数组最大值。</p>
<h3 id="673-最长递增子序列的个数"><a href="#673-最长递增子序列的个数" class="headerlink" title="673 最长递增子序列的个数"></a>673 最长递增子序列的个数</h3><p>2022-03-14</p>
<blockquote>
<p>给定一个未排序的整数数组 nums ， 返回最长递增子序列的个数 。<br>注意 这个数列必须是 严格 递增的。</p>
</blockquote>
<p>sol: 动态规划，类似#300但数组<code>dp&lt;pair&lt;int,int&gt;&gt;(len,[1,1])</code>记录以每个元素结尾的最长子序列长度和个数。</p>
<h3 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143 最长公共子序列"></a>1143 最长公共子序列</h3><p>2022-03-16</p>
<blockquote>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。<br>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
</blockquote>
<p>sol: 动态规划，二维数组，<code>dp[i][j] = dp[i-1][j-1]+1(text1[i]==text2[j)</code>,<code>dp[i][j] = max(dp[i-1][j],dp[i][j-1])</code></p>
<h3 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583 两个字符串的删除操作"></a>583 两个字符串的删除操作</h3><p>2022-03-16</p>
<blockquote>
<p>给定两个单词 word1 和 word2 ，返回使得 word1 和  word2 相同所需的最小步数。<br>每步 可以删除任意一个字符串中的一个字符。</p>
</blockquote>
<p>sol: 求出最长公共子序列长度后求长度差。</p>
<h3 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72 编辑距离"></a>72 编辑距离</h3><p>2022-03-16</p>
<blockquote>
<p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。<br>你可以对一个单词进行如下三种操作：<br>插入一个字符<br>删除一个字符<br>替换一个字符</p>
</blockquote>
<p>sol: 动态规划。插入/删除/替换分别对应一个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(word1[i]&#x3D;&#x3D;word2[j])&#123;</span><br><span class="line">    dp[i+1][j+1] &#x3D; 1+min(min(dp[i][j+1],dp[i+1][j]), dp[i][j] - 1);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    dp[i+1][j+1] &#x3D; 1+ min(min(dp[i+1][j], dp[i][j+1]),dp[i][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">DeeEll-X</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://deeell-x.github.io/2022/02/08/leetcode/">http://deeell-x.github.io/2022/02/08/leetcode/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/leetcode/">leetcode</a></div><div class="post_share"><div class="social-share" data-image="/null" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/02/14/CMU15445-Fall2019-Lab/"><img class="prev-cover" src="/null" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Database Systems(CMU 15445/645) Project</div></div></a></div><div class="next-post pull-right"><a href="/2021/08/18/mastering-regular-expressions/"><img class="next-cover" src="/null" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">mastering-regular-expressions</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/07/15/leetcode-2/" title="leetcode题解 - 2"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-15</div><div class="title">leetcode题解 - 2</div></div></a></div></div></div></article></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By DeeEll-X</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  var script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>