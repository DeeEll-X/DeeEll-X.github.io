<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C++ Primer Plus | Enclave-X</title><meta name="keywords" content="note,C++"><meta name="author" content="DeeEll-X"><meta name="copyright" content="DeeEll-X"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="头文件中的static inline函数：把希望全局使用又希望增加效率的函数放在头文件中static inline 第4章 复合类型raw原始字符串使用“( 和)”作为定界符，并使用R来标记原始字符串：cout &lt;&lt; R&quot;(Jim &quot;King&quot; Tutt uses &quot;\n&quot; instead of endl.)&quot; &lt;&amp;lt">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Primer Plus">
<meta property="og:url" content="http://deeell-x.github.io/2021/07/03/c-primer/index.html">
<meta property="og:site_name" content="Enclave-X">
<meta property="og:description" content="头文件中的static inline函数：把希望全局使用又希望增加效率的函数放在头文件中static inline 第4章 复合类型raw原始字符串使用“( 和)”作为定界符，并使用R来标记原始字符串：cout &lt;&lt; R&quot;(Jim &quot;King&quot; Tutt uses &quot;\n&quot; instead of endl.)&quot; &lt;&amp;lt">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://deeell-x.github.io/null">
<meta property="article:published_time" content="2021-07-03T03:42:04.000Z">
<meta property="article:modified_time" content="2021-07-27T01:49:35.354Z">
<meta property="article:author" content="DeeEll-X">
<meta property="article:tag" content="note">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://deeell-x.github.io/null"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://deeell-x.github.io/2021/07/03/c-primer/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-07-27 09:49:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">30</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">11</div></a></div></div></div><hr/></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">第4章 复合类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%85%B3%E7%B3%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">第5章 循环和关系表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E5%92%8C%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.</span> <span class="toc-text">第6章 分支语句和逻辑运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94c-%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97"><span class="toc-number">4.</span> <span class="toc-text">第7章 函数——c++的编程模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD"><span class="toc-number">5.</span> <span class="toc-text">第8章 函数探幽</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4"><span class="toc-number">6.</span> <span class="toc-text">第9章 内存模型和名称空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB"><span class="toc-number">7.</span> <span class="toc-text">第10章 对象和类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E4%BD%BF%E7%94%A8%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text">第11章 使用类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E7%B1%BB%E4%B8%8E%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">9.</span> <span class="toc-text">第12章 类与动态内存分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="toc-number">10.</span> <span class="toc-text">第13章 类继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-C-%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8"><span class="toc-number">11.</span> <span class="toc-text">第14章 C++中的代码重用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96"><span class="toc-number">12.</span> <span class="toc-text">第15章 友元、异常和其他</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93"><span class="toc-number">13.</span> <span class="toc-text">第16章 string类和标准模板库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E5%92%8C%E6%96%87%E4%BB%B6"><span class="toc-number">14.</span> <span class="toc-text">第17章 输入、输出和文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-%E6%8E%A2%E8%AE%A8C-%E6%96%B0%E6%A0%87%E5%87%86"><span class="toc-number">15.</span> <span class="toc-text">第18章 探讨C++新标准</span></a></li></ol></div></div></div><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Enclave-X</a></span><span id="menus"><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">C++ Primer Plus</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-07-03T03:42:04.000Z" title="Created 2021-07-03 11:42:04">2021-07-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-07-27T01:49:35.354Z" title="Updated 2021-07-27 09:49:35">2021-07-27</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>头文件中的static inline函数：把希望全局使用又希望增加效率的函数放在头文件中static inline</p>
<h2 id="第4章-复合类型"><a href="#第4章-复合类型" class="headerlink" title="第4章 复合类型"></a>第4章 复合类型</h2><p>raw原始字符串使用“( 和)”作为定界符，并使用R来标记原始字符串：<code>cout &lt;&lt; R&quot;(Jim &quot;King&quot; Tutt uses &quot;\n&quot; instead of endl.)&quot; &lt;&lt; &#39;\n&#39;</code>, 显示<br>内容为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jim &quot;King&quot; Tutt uses &quot;\n&quot; instead of endl.</span><br></pre></td></tr></table></figure>
<p>也可以自定义定界符，在”和(之间加入任意字符。左右要一致。</p>
<p>strnpy拷贝char*类型字符串，strlen计数字符串长度，不包含\0。</p>
<p>cin.getline遇到换行符终止并丢弃换行符。</p>
<p>cin.get遇到换行符终止但是换行符还留在输入流中，可以用cin.get来获取换行符数组char array[], array为第一个元素的地址，&amp;array为整个数组的地址。<code>cin.get(...,..).get();</code>后面一个get来获取换行符。</p>
<p>malloc分配的地址在堆上，所以vector的存储空间在堆上。</p>
<h2 id="第5章-循环和关系表达式"><a href="#第5章-循环和关系表达式" class="headerlink" title="第5章 循环和关系表达式"></a>第5章 循环和关系表达式</h2><p>c++将赋值表达式的值定义为左侧成员的值，x=y=z=0是右结合的。</p>
<p>cout.setf(ios_base::boolalpha)可以将cout显示true false而不是1 0。</p>
<p>回忆vector的实现，++n的实现比n++的代码量少，还少了一次拷贝，前缀的效率更高，所以尽量用前缀。</p>
<p>后缀++ 的优先级比取引用<code>*</code>优先级高，所以<code>*p++</code>是去的p所在位置的值，p的指针往后移一位。</p>
<p>strcmp(a,b)使用系统排列顺序比较字符串是否相等（char数组/字符串常量/指针），大写字母<code>&gt;</code>小写字母，<code>a&gt;b</code>返回正数，<code>a&lt;b</code> 返回负数。string类型重载了=运算符所以可以直接比较。</p>
<p><strong>【通常，编写清晰、容易理解的代码比使用语言的晦涩特性来显示自己的能力更为有用】</strong></p>
<p>cin.get(char)来避免忽略空格/换行/制表符，返回值是istream对象，即cin，所以cin.get(a).get(b)顺序读取a和b的值。注意存在缓冲区所以输入字符数可能会多于处理字符数。</p>
<p>使用eof来检测文件尾：cin.eof()（eofbit是否被设置）/cin.fail()（eofbit或failbit是否被设置）while(cin)检测最后一次读取是否成功（eof）。</p>
<h2 id="第6章-分支语句和逻辑运算符"><a href="#第6章-分支语句和逻辑运算符" class="headerlink" title="第6章 分支语句和逻辑运算符"></a>第6章 分支语句和逻辑运算符</h2><p>复习一下unix的文件输入输出。</p>
<ol>
<li><p>cin类型不匹配的时候，如int n;cin&gt;&gt;n; 会发生</p>
<ul>
<li><p>n的值保持不变，</p>
</li>
<li><p>不匹配的输入被留在输入队列里</p>
</li>
<li><p>cin对象的一个错误标记被设置</p>
</li>
<li><p>对cin方法的调用将返回false（如果被转换为bool类型）</p>
<p>类型输入错误标记意味着必须重置才能继续读取输入。<code>cin.clear()</code>方法重置错误输入标记，同时也重置文件尾（EOF条件）。</p>
</li>
</ul>
</li>
<li><p><code>cin.fail()</code>可以检测cin最近一次输入是否：1. 输入类型不匹配 2. 遇到EOF</p>
</li>
<li><p>使用文件输出 </p>
<p> (1) 包含头文件fstream<br> (2) 创建一个ofstream对象<br> (3) 将该ofstream对象和一个文件关联起来(用<code>open</code>)<br> (4) 像使用cout那样使用ofstream对象<br> (5) 输出完之后应该用close将文件关闭(<code>outfile.close()</code>不需要参数)</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ofstream outfile;</span><br><span class="line">outfile.open(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">outfile &lt;&lt; <span class="string">&quot;test input to file.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">...</span><br><span class="line">outfile.close();</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用文件输入：</p>
<p> (1) 包含头文件fstream，注意使用命名空间std<br> (2) 创建ifstream对象<br> (3) 将该ifstream对象和一个文件关联起来(用<code>open</code>)<br> (4) 像使用cin那样使用ifstream对象。除了<code>&gt;&gt;</code>，可以用<code>get()</code>来获取一个字符，用<code>getline()</code>来读取一行字符。<br> (5) 类似，ifstream对象本身作为测试条件时，如果最后一个读取操作成功，它将被转换为bool值true,否则是false<br> (6) 检查文件是否被成功打开：<code>file.is_open()</code><br> (7) file.fail()检查是否有类型不匹配或者eof；file.bad()检查文件受损/硬件故障等意外问题；file.good()在没有发生任何错误时（即最后一次读取操作成功）返回true<br> (8) 输入完之后应该用close将文件关闭(<code>infile.close()</code>不需要参数)</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ifstream inFile;</span><br><span class="line">inFile.open(&quot;test.txt&quot;);</span><br><span class="line">if(!inFile.is_open())&#123;</span><br><span class="line">    exit(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">double value;</span><br><span class="line">inFile &gt;&gt; value;</span><br><span class="line">while(inFile.good())&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">if(inFile.eof())&#123;</span><br><span class="line">    cout &lt;&lt; &quot;End of file reached.&quot; &lt;&lt;endl;</span><br><span class="line">&#125; else if (inFile.fail())&#123;</span><br><span class="line">    cout&lt;&lt; &quot; Input terminated by data mismatch.&quot; &lt;&lt;endl;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    cout &lt;&lt; “Input terminated by unkown reason.&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">inFile.close();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="第7章-函数——c-的编程模块"><a href="#第7章-函数——c-的编程模块" class="headerlink" title="第7章 函数——c++的编程模块"></a>第7章 函数——c++的编程模块</h2><ol>
<li><p>禁止将const地址赋给非const的指针，可以用强制类型转换<code>cosnt_cast</code></p>
</li>
<li><p>尽可能使用const：</p>
<ul>
<li>避免无意间修改数据</li>
<li>使用const使得函数能够处理const和非const实参，否则将只能接受非const数据</li>
<li>使用const引用是函数能够正确生成并使用临时变量<ul>
<li>实参类型正确但不是左值</li>
<li>实参类型不正确但可以转换为正确的类型</li>
</ul>
</li>
</ul>
</li>
<li><p>const修饰的数组/指针作为函数参数时只能用于指向基本类型的指针，不能用于指向指针/指向指针的指针。</p>
</li>
<li><p>函数指针<br> (1) 声明：<code>double (*pam)(int);</code><br> (2) <code>pam</code>与<code>(*pam)</code>等价<br> (3) 调用方法与普通函数相同<br> (4) 将函数作为参数传递时，必须传递函数名 </p>
</li>
</ol>
<h2 id="第8章-函数探幽"><a href="#第8章-函数探幽" class="headerlink" title="第8章 函数探幽"></a>第8章 函数探幽</h2><ol>
<li><p>引用常被用作函数参数。<code>int&amp;</code> 类似<code>int * const</code>，在一开始就要被初始化。</p>
</li>
<li><p>函数特化与函数重载的调用顺序： 非模板函数 &gt; 特化函数 &gt; 常规模板</p>
</li>
<li><p><code>decltype(expression)</code>用于推断数据类型</p>
<ul>
<li>expression是一个没有用括号括起的标识符，则var类型和标识符类型相同，包括const等限定符</li>
<li>expression是一个函数调用，则var类型与函数返回类型相同</li>
<li>expression是一个左值，var为指向其类型的引用。<code>decltype((x))</code> 若x类型为int，返回int&amp;   </li>
</ul>
</li>
<li><p>用于由编译器来推断返回值的语法</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">auto gt(T1 x, T2 y) -&gt; decltype(x+y)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    return x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="第9章-内存模型和名称空间"><a href="#第9章-内存模型和名称空间" class="headerlink" title="第9章 内存模型和名称空间"></a>第9章 内存模型和名称空间</h2><ol>
<li><p>头文件放以下东西，不要把函数定义（除非是内联函数）和变量声明放头文件（放const符号常量可以）防止同一个程序中包含一个函数的两个定义</p>
<ul>
<li>函数原型</li>
<li>用#define或const符号常量</li>
<li>结构/类声明</li>
<li>模版声明</li>
<li>内联函数函数定义可以</li>
</ul>
</li>
<li><p>所有未初始化的静态变量的所有位都被设置为0（回想ICS中静态和全局变量未初始化时的存放区域）静态变量在初始化时，首先所有静态变量都被零初始化，而不管程序员是否显式初始化了它，接下来如果使用常量表达式初始化了变量，且编译器仅根据文件内容（包括被包含的头文件）就可计算表达式，编译器将执行常量表达式初始化。如果没有足够的信息，变量将被动态初始化（等待被链接且程序执行时）。</p>
</li>
<li><p>constexpr关键字用于创建常量表达式。</p>
<ul>
<li>constexpr用于变量声明或者一个非静态成员函数声明时，与const等同。</li>
<li>constexpr用于一个函数或者静态成员变量声明时，意味着inline。</li>
<li>当声明一个constexpr函数时，如果参数都是编译期常量，对这个函数的调用就可以用于期望常量表达式的场合；如果参数的值在运行期才能确定，或者虽然参数的值是编译期常量但是不匹配函数的要求，则对这个函数调用的求值只能在运行期进行。</li>
</ul>
</li>
<li><p>在多个文件中使用外部变量（全局变量），只需在一个文件中包含该变量的定义（单定义规则）但在使用该变量的其他所有文件都必须使用关键字external声明它。C++提供了作用解析运算符，放在变量名前面时，该运算符表示使用变量的全局版本::warming表示使用全局变量warming（最好是使用命名空间</p>
</li>
<li><p>volatile关键字表示即使程序代码没对内存单元进行修改，其值也可能发生变化。</p>
</li>
<li><p>mutable关键字：即使结构/类变量为const,其某个成员也可以被修改（出现在类里面变量声明前）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> accesses;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> data veep = &#123;<span class="string">&quot;Claybourne clodde&quot;</span>, <span class="number">0</span>, ...&#125;;</span><br><span class="line"><span class="built_in">strcpy</span>(veep.name, <span class="string">&quot;Joye Joux&quot;</span>); <span class="comment">// not allowed</span></span><br><span class="line">veep.accesses++;                <span class="comment">// allowed</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定位new运算符：指定要使用的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (addr) T ;</span><br><span class="line"><span class="keyword">new</span> (addr) T[];</span><br></pre></td></tr></table></figure>
</li>
<li><p>using：using声明将特定的名称添加到它所属的声明区域，如<code>using Jill::fetch</code>, using编译指令使得所有的名称都可用，如<code>using namespace std;</code> using声明比使用using编译指令更安全，因为它只导入指定的名称未命名的名称空间：【不能在未命名名称空间所属文件之外】的其他文件中使用该名称空间中的名称。这提供了链接性为内部的静态变量的替代品。不在头文件中使用using编译指令。用命名空间中声明的变量来取代全局变量和static变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counts;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可替换为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> counts;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="第10章-对象和类"><a href="#第10章-对象和类" class="headerlink" title="第10章 对象和类"></a>第10章 对象和类</h2><ol>
<li><p>当类方法实现直接写在类声明中，这个方法是inline的。</p>
</li>
<li><p>以下代码无法通过编译，因为位于相同的作用域内。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> egg &#123;Small, Medium, Large, Jumbo&#125;;</span><br><span class="line"><span class="keyword">enum</span> tshirt &#123;Small, Medium,Large, XLarge&#125;;</span><br></pre></td></tr></table></figure>
<p>c++11为解决这种问题提供了一种新枚举，枚举量的作用域为类:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">egg</span> &#123;</span>Small, Medium, Large, Jumbo&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">tshirt</span> &#123;</span>Small, Medium,Large, XLarge&#125;;</span><br></pre></td></tr></table></figure>
<p>枚举量的作用域为类，枚举量就不会产生名称冲突。</p>
</li>
<li><p>作用域内枚举量不能被隐式转换为整型，需要显式类型转换。</p>
</li>
<li><p>作用域内枚举量可以指定底层整型类型表示：enum class :short pizza{Small, Medium, Large, XLarge}</p>
</li>
</ol>
<h2 id="第11章-使用类"><a href="#第11章-使用类" class="headerlink" title="第11章 使用类"></a>第11章 使用类</h2><ol>
<li><p>operator+()为成员函数时，运算符左侧是调用对象，运算符右侧是作为参数被传递的对象</p>
</li>
<li><p>友元函数：该函数与类的成员函数拥有相同的访问权限（私有成员）</p>
</li>
<li><p><code>friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const c_name&amp;obj);</code>因为(cout&lt;&lt; A) &lt;&lt; B左结合并返回一个cout</p>
</li>
<li><p>重载运算符：</p>
<ul>
<li>成员函数版本：一个操作数通过this指针隐式传递，另一个通过函数参数显式传递 </li>
<li>友元函数版本：两个操作数都作为参数传递。 </li>
<li>不能同时选择两种格式，会导致编译中二义性错误</li>
</ul>
</li>
<li><p>类的自动转换：只有接受一个参数的构造函数才能作为转换函数。explicit关键字用于关闭自动转换特性。</p>
</li>
<li><p>创建转换函数：<code>operator typename();</code>比如转换为double类型的函数原型：<code>operator double(); </code></p>
<ul>
<li>转换函数必须是类方法</li>
<li>不能指定返回类型</li>
<li>不能有参数<br>int()将待转换的值四舍五入为最近的整数。谨慎使用隐式转换函数，最好使用只在被显式调用时才被执行的函数。</li>
</ul>
</li>
</ol>
<h2 id="第12章-类与动态内存分配"><a href="#第12章-类与动态内存分配" class="headerlink" title="第12章 类与动态内存分配"></a>第12章 类与动态内存分配</h2><ol>
<li><p>不能在类声明中初始化静态成员变量：声明描述了如何分配内存，但并不分配内存。对于静态类成员，可以在类声明之外使用单独的语句进行初始化。这是因为静态类成员是单独存储的，而不是对象的组成部分。</p>
<ul>
<li>非静态可用C++11提供的类内初始化，用{}/=在声明文件中说明初始化值，和成员初始化列表等价。</li>
<li>const int可以在声明中提供初始化值。</li>
</ul>
</li>
<li><p>c++自动提供了以下成员函数：默认构造函数/默认析构函数/复制构造函数/赋值运算符/地址运算符，C++11之后还提供了移动构造函数/移动赋值运算符。</p>
<ul>
<li>带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值。</li>
</ul>
</li>
<li><p><code>delete[]</code>可用于<code>new[]</code>/空指针。</p>
</li>
<li><p><code>opera[4]</code>可被编译器转换为<code>opera.operator[](4)</code>。</p>
</li>
<li><p>const对象只会调用类的const成员方法。</p>
</li>
<li><p>类的静态成员函数不与特定的对象相关联，因此只能使用静态数据成员。</p>
</li>
<li><p>返回指向非const对象的引用：重载赋值运算符（连续赋值）和重载与cout一起使用&lt;&lt;运算符（串接输出）。</p>
</li>
<li><p><code>force1 + force2 = net;</code>这个语句也是可行的。<code>force1+force2</code>返回一个临时对象，<code>net</code>的值被赋值给这个临时对象。</p>
</li>
<li><p>嵌套结构和类：如果嵌套结构的声明在类的私有部分进行，只能在这个类中使用被声明的类型；如果声明在公有部分进行，则可以在类的外面声明A::B类型的变量。</p>
</li>
</ol>
<h2 id="第13章-类继承"><a href="#第13章-类继承" class="headerlink" title="第13章 类继承"></a>第13章 类继承</h2><ol>
<li><p>派生类对象存储了基类的（公有/protected）数据成员（派生类继承了基类的实现）；派生类对象可以使用基类的方法（派生类继承了基类的接口）。</p>
</li>
<li><p>派生类构造函数必须使用基类构造函数：在创建派生类对象时，程序首先创建基类对象，如在构造函数中不调用基类构造函数，程序将使用默认的基类构造函数（在实现中应当显式调用正确的基类构造函数）。</p>
<ul>
<li>创建派生类对象时，将调用派生类的构造函数，派生类的构造函数将使用基类的一个构造函数，这种顺序不同于继承机制，因此派生类不继承基类的构造函数，所以将类构造函数声明为虚的没有意义。</li>
</ul>
</li>
<li><p>派生类对象过期时，首先调用派生类析构函数，然后再调用基类析构函数。派生类对象可以通过.method()使用基类的公有方法。</p>
</li>
<li><p>不能把基类对象和地址赋给派生类引用和指针（需要显式类型转换）。</p>
</li>
<li><p>virtual关键字：没有virtual，程序根据应用类型或指针类型选择方法；使用virtual，程序根据引用或指针指向的对象的类型选择方法。</p>
</li>
<li><p>使用虚析构函数的原因：如果析构函数不是虚的，则将只调用对应于指针类型的析构函数。应当给基类提供一个虚析构函数，即使它并不需要析构函数。（当基类指针指向派生类对象时，该对象被析构，如果基类的析构函数不是虚函数，就会调用基类的析构函数，此时派生类新增的数据成员就无法被正确析构）</p>
</li>
<li><p>构造函数不能被继承；析构函数不能被继承，释放时首先调用派生类的析构函数再调用基类的析构函数；赋值运算符不能被继承。</p>
</li>
<li><p>编译器处理虚函数：为每个对象添加了一个指向函数地址数组（虚函数表）的指针。虚函数表中存储了为类对象进行声明的虚函数的地址。使用虚函数时，内存和执行速度方面都有一定的成本：每个对象都将增大，增大量为存储地址的空间；每个类编译器都创建一个虚函数地址表（数组）；每个虚函数调用，都需要到虚函数表中查找地址。</p>
</li>
<li><p>重新定义将隐藏方法。如果重新定义继承的方法，应确保与原来的原型完全一致，但如果返回类型是基类引用或指针，可以修改为指向派生类的引用或指针。</p>
</li>
<li><p>protected：派生类可以访问。</p>
</li>
<li><p>派生类使用作用域解析运算符来调用公有和受保护的基类方法。</p>
</li>
</ol>
<h2 id="第14章-C-中的代码重用"><a href="#第14章-C-中的代码重用" class="headerlink" title="第14章 C++中的代码重用"></a>第14章 C++中的代码重用</h2><ol>
<li><p>C++包含让程序员能够限制程序结构的特性-使用explicit防止单参数构造函数的隐式转换，使用const限制修改数据等。根本原因在于：在编译阶段出现错误优于在运行阶段出现错误。</p>
</li>
<li><p>私有继承：has-a关系，基类的公有成员和保护成员都将成为派生类的私有成员。</p>
<ul>
<li>基类方法不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中通过<em>类名和作用域解析运算符</em>来使用它们。</li>
<li>私有继承的派生类不能隐式向上转换：私有继承中未进行显式类型转换的派生类引用或指针无法赋值给基类的引用或指针。</li>
<li>通常使用包含来建立has-a关系：如果新类需要访问原有类的保护成员或需要重新定义虚函数，应使用私有继承。</li>
</ul>
</li>
<li><p>保护继承：has-a关系，基类的公有成员和保护成员都将成为派生类的保护成员。</p>
<ul>
<li>与私有继承的区别在于第三代派生类是否可以使用基类的公有成员。</li>
<li>可以隐式向上转换。</li>
</ul>
</li>
<li><p>多重继承：要用public关键字限定每一个基类，否则编译器会认为是私有派生。</p>
</li>
<li><p>虚基类：多个类（它们的基类相同）派生出的对象只继承一个基类对象。</p>
<ul>
<li>此时代码例如<code>class Singer: virtual pulic Worker&#123;…&#125;;</code>或<code>class Waiter: virtual public Worker&#123;…&#125;;</code></li>
<li>注意，虚基类不是多MI的默认行为，将基类作为虚的要求程序完成额外的计算，<strong>为不需要的工具付出代价是不应当的</strong>。</li>
<li>在虚基类中，编译器必须在构造派生对象前构造基类对象组件，一般是用默认构造函数，否则应当如下：<code>SingingWaiter(const Worker&amp; wk, int p = 0, int v = Singer::other): Worker(wk), Waiter(wk, p), Singer(wk, v)&#123;&#125;</code>这种用法仅对虚基类合法。</li>
</ul>
</li>
<li><p>多重继承调用方法存在二义性：</p>
<ol>
<li>使用作用域解析运算符<code>singingwaiter.Singer::Show()</code></li>
<li>在派生类中重新定义Show()</li>
</ol>
</li>
<li><p>虚二义性规则：派生类中的名称优先于直接或间接祖先类中的相同名称。虚二义性规则与访问规则无关。即使某个方法是私有的不能访问，但其仍然可以优先于另一个公有成员。</p>
</li>
<li><p>不能将模版成员函数放在独立的实现文件中。由于模版不是函数，它们不能单独编译。模版必须和特定的模版实例化请求一起使用，为此，最简单的方法是将所有模版信息放在一个头文件中。</p>
</li>
<li><p>模版别名<code>template &lt;typename T&gt; using arrtype = std::array&lt;T,12&gt;;</code>此时将arrtype定义为一个模版别名，可以使用它来指定类型如<code>arrtype&lt;double&gt; gallons;</code></p>
</li>
</ol>
<h2 id="第15章-友元、异常和其他"><a href="#第15章-友元、异常和其他" class="headerlink" title="第15章 友元、异常和其他"></a>第15章 友元、异常和其他</h2><ol>
<li><p>友元类</p>
<ul>
<li>所有方法都可以访问原始类的私有/保护成员。</li>
<li>友元类所在的位置无所谓：公有/私有/保护部分。</li>
<li>可选择仅让特定的类成员成为一个类的友元<code>friend void Remote::set_chan(Tv &amp; t, int c);</code>。</li>
</ul>
</li>
<li><p>避免类间循环依赖的方法：使用forward declaration。</p>
</li>
<li><p>throw关键字表示引发异常。该语句实际上是跳转，命令程序跳到另一条语句（catch）。</p>
<ul>
<li>引发异常时编译器总是创建一个临时拷贝，即使异常规范和catch块中指定的是引用。好处是调用函数发生异常后，等这个函数结束时，throw的自动变量已经不再存在。</li>
<li>c++11 noexcept关键字表示函数不会引发异常。</li>
<li>如果throw没有catch的异常处理程序，默认情况下程序将异常终止。<ul>
<li>未捕获异常的处理：默认情况下导致程序异常终止。未捕获异常不会导致程序立刻异常终止。首先调用函数terminate()，默认情况下，terminate()函数调用abort()函数，可以指定terminate()应调用的函数来修改terminate()的行为<code>set_terminate(一个返回void入参为空的指针)</code>。</li>
<li>函数调用的其他函数引发的异常：程序调用unexpected函数，该函数调用terminated，后者在默认情况下调用abort。也有一个set_unexpected函数。</li>
</ul>
</li>
<li>catch块的排列顺序应该与类的派生顺序相反。</li>
<li>catch(…)用省略号表示异常类型，从而捕获任何异常。</li>
</ul>
</li>
<li><p>C++提供了一种在失败时返回空指针的new：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pi = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) <span class="keyword">int</span>; </span><br><span class="line"><span class="keyword">int</span>* pa = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) <span class="keyword">int</span>[<span class="number">500</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>RTTI(Runtime Type Identification):</p>
<ol>
<li>dynamic_cast 回答能否安全地将对象的地址赋给特定类型的指针，若否则该运算符返回0-空指针。只允许类的向上转换(派生类到基类)。</li>
<li>typeid(类名)返回一个对type_info对象的引用。type_info类包含一个name()成员</li>
</ol>
</li>
<li><p>const_cast可以去掉/加上const; static_cast同时允许向上转换和向下转换，也允许各种数值转换。</p>
</li>
</ol>
<h2 id="第16章-string类和标准模板库"><a href="#第16章-string类和标准模板库" class="headerlink" title="第16章 string类和标准模板库"></a>第16章 string类和标准模板库</h2><ol>
<li>string类：<ul>
<li>将string::npos定义为字符串的最大长度，通常为unsigned int的最大值。</li>
<li>输入string的方法：<ul>
<li><code>cin.operator&gt;&gt;(str);</code>ostream class method</li>
<li><code>operator&gt;&gt;(cin,str);</code> regular funciton</li>
</ul>
</li>
<li>string库是<code>basic_string&lt;char&gt;</code>类型的。基于一个模板类，其中char可以替换为<code>wchar_t</code>/<code>char16_t</code>/<code>char32_t</code>。</li>
</ul>
</li>
<li>智能指针模板类<ul>
<li><code>auto_ptr</code>优点在于析构时会自动销毁空间，问题在于两个<code>auto_ptr</code>指向同一块内存区域时会释放两次造成segmentation fault。</li>
<li><code>unique_ptr</code>为临时对象时允许赋值，否则禁止，可以显式地使用<code>std::move</code>。<ul>
<li>存在用于数组的变体<code>std::unique_ptr&lt;double[]&gt;pda(new double [5]);</code></li>
</ul>
</li>
<li><code>shared_ptr</code>引用计数。<ul>
<li>包含一个显式构造函数，可用于将右值<code>unique_ptr</code>转换为<code>shared_ptr</code>，此时<code>shared_ptr</code>接管原来<code>unique_ptr</code>的对象。</li>
</ul>
</li>
</ul>
</li>
<li>标准模板库<br> + <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;classT, <span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> = <span class="title">allocator</span>&lt;T&gt;&gt;</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">vector</span>&#123;</span>...&#125;</span><br></pre></td></tr></table></figure>
 默认使用<code>allocator&lt;T&gt;</code>类，这个类使用new和delete。<ul>
<li>STL文档使用[p1, p2)表示p1到p2（不包含p2）的区间。</li>
<li><code>for_each(iterator1, iterator2, func);</code>最后一个参数是函数对象。<code>for_each</code>中被指向的函数不能修改容器元素的值。</li>
<li>可以写为<code>for(auto&amp; x : container) func(x);</code></li>
</ul>
</li>
<li>泛型编程<ul>
<li>迭代器类型<ul>
<li>输入迭代器(input iterator)单向迭代器，可递增(支持++运算符)，可读不可写。</li>
<li>输出迭代器(output iterator)单向迭代器，可递增(支持++运算符)，可写不可读。</li>
<li>正向迭代器(forward iterator)，单向迭代器，可递增(支持++运算符)，可读可写可多次同行（对前面的迭代器解除引用，输入输出迭代器不行）。</li>
<li>双向迭代器，具有正向迭代器的所有特性，同时支持两种(前缀后缀–运算符)。</li>
<li>随机访问迭代器(random access iterator)，能够直接跳到容器中任何一个元素，有双向迭代器的所有特性，同时添加了支持随机访问的操作和对元素进行排序的关系运算符。</li>
</ul>
</li>
<li>迭代器的类型不是确定的，只是一种概念性描述。每个容器类都定义了一个类级typedef名称：<code>iterator</code></li>
<li><code>concept</code>用于描述一系列要求。<code>model</code>指<code>concept</code>具体实现。<code>refinement</code>指概念上的继承(如正向迭代器到双向迭代器到随机访问迭代器)。</li>
<li>适配器(adaptor)可以将一些接口转换为STL使用的接口。例如<code>ostream_iterator&lt;int,char&gt; out_iter(cout, &quot; &quot;);</code>还有<code>istream_iterator, reverse_iterator, back_insert_iterator,front_insert_iterator, insert_iterator</code>。<ul>
<li><code>rbegin, rend</code>前者返回一个指向超尾的反向迭代器，后者返回指向第一个元素的反向迭代器。对迭代器执行递增操作将导致迭代器被递减。</li>
</ul>
</li>
<li>deque模版类表示双向队列，与vector区别在于从deque对象的开始位置插入和删除元素的时间是固定的，而不是像vector那样线性时间。</li>
<li>关联容器是对容器概念的一种改进，将值和键关联在一起。<ul>
<li><code>set_union(A.begin(),A.end(),B.begin(),B.end(),insert_iterator&lt;set&lt;string&gt;&gt;(C,C.begin()));</code>这样写是因为关联集合将键看作常量，<code>C.begin()</code>返回的是常量迭代器而不能作为输出迭代器；且<code>set_union</code>若覆盖容器中已有的内容，要求容器有足够空间容纳新信息。</li>
</ul>
</li>
</ul>
</li>
<li>函数对象<ul>
<li>函数对象，又称函数符（functor），指可以函数方式与<code>()</code>结合使用的任意对象，包括函数名，函数指针，和重载了<code>()</code>运算符的类对象。</li>
<li>predicate：返回bool值的一元函数。binary predicate：返回bool值的二元函数。</li>
<li>预定义的函数符：如有<code>plus&lt;T&gt;()</code>,<code>minus&lt;T&gt;()</code>等。</li>
<li><code>std::bind</code>可以将自适应多元函数符转换为自适应X元函数符。</li>
</ul>
</li>
<li>算法<ul>
<li>STL有很多处理容器的非成员函数，例如<code>sort(), copy(), find(), random_shuffle(), set_union()</code>等。它们都使用模版提供泛型，用迭代器提供访问容器中数据的通用表示。</li>
<li>remove()方法不是成员函数，此时对链表应用不会修改链表的长度，而是将对应元素移动到链表最后。</li>
</ul>
</li>
<li>尽可能使用initializer_list进行初始化。    </li>
</ol>
<h2 id="第17章-输入、输出和文件"><a href="#第17章-输入、输出和文件" class="headerlink" title="第17章 输入、输出和文件"></a>第17章 输入、输出和文件</h2><ol>
<li><p>c++程序处理输入：</p>
<ol>
<li>将字节流与输入去向的程序关联起来 </li>
<li>将流与文件关联起来。</li>
</ol>
</li>
<li><p>使用缓冲区可以更高效地处理输入和输出：程序通常只能处理一个字节的信息；从内存中读取单个字节比从硬盘上读取快很多。刷新缓冲区：输出时程序首先填满缓冲区，然后将整块数据传输给硬盘并清空缓冲区。</p>
</li>
<li><p>键盘输入每次只一个字符，程序无需缓冲区来帮助匹配不同的数据传输速率。对键盘缓冲可以让用户在将输入传输给程序前返回并更正。C++程序通常在用户按回车键时刷新缓存区。</p>
</li>
<li><p>在包含iostream文件时将自动创建8个流对象（4个窄字符流，4个宽字符流）：cin,cout,cerr,clog/wcin,wcout,wcerr,wclog，</p>
<ul>
<li>对象代表流：当iostream文件为程序声明一个cout对象时，该对象将包含存储输出有关的数据成员，如显示数据时使用的字段宽度、小数位数、显示整数时采用的计数方法和描述用来处理输出流的缓冲区的streambuf对象的地址。</li>
</ul>
</li>
<li><p>重定向：命令行中的<code>&lt;</code>,<code>&gt;</code>将标准输入/输出与某个文件关联起来，使得cin/cout从文件进行输入输出。使用<code>2&gt;</code>重定向标准错误。</p>
</li>
<li><p>cout: ostream重载和拼接(cout&lt;&lt;返回ostream&amp;也就是cout)</p>
<ul>
<li><code>ostream&amp; put(char);</code></li>
<li>write方法用于显示整个字符串：<code>basic_stream&lt;charT, traits&gt;&amp; write(const char_type* s,, streamsize n);</code>使用cout调用write时将调用char具像化，因此返回类型为ostream&amp;。<ul>
<li>write方法不会遇到空字符时自动停止打印字符，只是指定打印指定数目的字符，即使超出字符的边界。write方法也可用于数值字符（long等类型），它会传输内存中存储的位表示，而不是把数字转换为相应的字符，为数值数据存储在文件中提供了一种简洁准确的方式。</li>
</ul>
</li>
<li>在屏幕输出时，程序不必等到缓冲区被填满，例如，将换行符发送到缓冲区后将刷新缓冲区。大多数c++实现还会在输入即将发生时刷新缓存区。控制符flush刷新缓存区，控制符endl刷新缓存区并插入一个换行符。可以写成<code>flush(cout)</code>或<code>cout&lt;&lt;flush</code>。</li>
<li>改变显示整数时的计数系统：<code>hex(cout)</code>或者<code>cout&lt;&lt;hex</code>。控制符实际上是函数（但不是成员函数），ostream重载了&lt;&lt;运算符，使得上述用法与函数调用<code>hex(cout)</code>等价。</li>
<li><code>width</code>【成员函数】将不同长度的数字放到宽度相同的字段中。字符是右对齐的，但是只影响接下来显示的一个项目，然后字段宽度将恢复为默认值。</li>
<li><code>fill</code>【成员函数】改变字段中未使用部分的填充字符（默认是空格）。一旦设置一直有效。</li>
<li><code>precision</code>【成员函数】设置浮点数显示精度，一直有效直至重新被设置。</li>
<li><code>setf</code> 方法设置了小数点被显示时的其他几个格式选项。unsetf可消除效果。也可以用一些标准控制符来实现setf的功能。</li>
</ul>
</li>
<li><p>C++将十六机制和八进制都看作无符号的。</p>
</li>
<li><p>cin：可以使用<code>cin&gt;&gt;hex</code>;来将整数输入解释为八进制。</p>
<ul>
<li><code>&gt;&gt;</code>运算符读取从非空白字符开始到目标类型不匹配的第一个字符之间所有的内容。</li>
<li>流状态：3个<code>ios_base</code>元素组成<ul>
<li><code>eofbit</code>(cin到文件末尾),</li>
<li><code>badbit</code>(无法诊断的失败破坏流)</li>
<li><code>failbit</code>(cin操作未能读到预期的字符：此时不会修改被输入对象的值并返回0，I/O失败)</li>
<li>可使用<code>clear</code>重置状态，清除3个状态位。</li>
<li>设置流状态位：流将对后面的输入或输出关闭，直到位被清除。可调用clear将位清除。</li>
</ul>
</li>
<li><code>cin.get(void)</code>读取空白字符返回一个int值，<code>cin.get(char &amp;)</code>返回一个指向用于调用它的istream的对象的引用</li>
<li><code>cin.peek()</code>函数返回输入的下一个字符但不抽取输入流中的字符</li>
</ul>
</li>
<li><p>文件输入输出<code>fstream</code>将iostream方法扩展到文件I/O的类定义。可以使用对应的istream/ostream方法来读写文件。</p>
</li>
</ol>
<h2 id="第18章-探讨C-新标准"><a href="#第18章-探讨C-新标准" class="headerlink" title="第18章 探讨C++新标准"></a>第18章 探讨C++新标准</h2><ol>
<li><code>&#123;&#125;</code>初始化：防止缩窄转换。</li>
<li><code>decltype</code>关键字将变量的类型声明为表达式指定的类型。<ul>
<li>可用于返回类型后置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename U&gt;</span><br><span class="line">auto eff(T t, U u) -&gt; decltype(T*U)</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>nullptr</code>为表示空指针提供了类型安全。由于C++允许用0来表示空指针，所以<code>nullptr == 0</code>为true。</li>
<li><code>cbegin</code>和<code>cend</code>将元素视为<code>const</code>。</li>
<li>如果实参为右值， const引用形参将指向一个临时变量。</li>
<li><code>default</code>关键字用于显式声明6个特殊成员函数；<code>delete</code>用于禁止编译器使用特定方法，可用于任何成员函数（比如用于禁止特定的转换）</li>
<li>管理虚方法：<code>override</code>和<code>final</code><ul>
<li><code>override</code>用于编译器检查覆盖虚函数的声明是否与基类方法匹配。</li>
<li><code>final</code>用于禁止派生类覆盖（override）特定的虚方法。用法与override一致。</li>
</ul>
</li>
<li><code>std::function</code>是一种wrapper，用于包装call signature相同的函数指针、函数对象和lambda表达式。<ul>
<li><code>std::function</code>是一个模版类，相同call signature的只实例化一次。</li>
</ul>
</li>
<li>可变参数模版： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_list</span><span class="params">(<span class="keyword">const</span> T&amp; value)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_list</span><span class="params">(<span class="keyword">const</span> T&amp; value, <span class="keyword">const</span> Args&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    show_list(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">DeeEll-X</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://deeell-x.github.io/2021/07/03/c-primer/">http://deeell-x.github.io/2021/07/03/c-primer/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/note/">note</a><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="/null" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/03/templateprogramming/"><img class="prev-cover" src="/null" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">C++模版元编程</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/09/trading-system/"><img class="next-cover" src="/null" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">trading system 项目笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2021/07/03/templateprogramming/" title="C++模版元编程"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-03</div><div class="title">C++模版元编程</div></div></a></div><div><a href="/2021/07/04/cppcon-lambda-expression/" title="cppcon lambda expression"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-04</div><div class="title">cppcon lambda expression</div></div></a></div><div><a href="/2021/07/13/good-concept/" title="good-concept"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-13</div><div class="title">good-concept</div></div></a></div><div><a href="/2020/10/15/KeylessSSL/" title="Keyless SSL, The Nitty Gritty Technical Details"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-15</div><div class="title">Keyless SSL, The Nitty Gritty Technical Details</div></div></a></div><div><a href="/2020/10/11/PKCS/" title="Public-Key Cryptography Standards, PKCS"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-11</div><div class="title">Public-Key Cryptography Standards, PKCS</div></div></a></div><div><a href="/2020/10/21/Effective-Modern-Cpp1/" title="Effective Modern Cpp(1) Deducing Types"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-21</div><div class="title">Effective Modern Cpp(1) Deducing Types</div></div></a></div></div></div></article></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By DeeEll-X</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  var script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>